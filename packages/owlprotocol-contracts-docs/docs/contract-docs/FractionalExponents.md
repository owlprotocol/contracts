

## FractionalExponents

### ONE

```solidity
uint256 ONE
```

### MAX_WEIGHT

```solidity
uint32 MAX_WEIGHT
```

### MIN_PRECISION

```solidity
uint8 MIN_PRECISION
```

### MAX_PRECISION

```solidity
uint8 MAX_PRECISION
```

### FIXED_1

```solidity
uint256 FIXED_1
```

### FIXED_2

```solidity
uint256 FIXED_2
```

### MAX_NUM

```solidity
uint256 MAX_NUM
```

### LN2_NUMERATOR

```solidity
uint256 LN2_NUMERATOR
```

### LN2_DENOMINATOR

```solidity
uint256 LN2_DENOMINATOR
```

### OPT_LOG_MAX_VAL

```solidity
uint256 OPT_LOG_MAX_VAL
```

### OPT_EXP_MAX_VAL

```solidity
uint256 OPT_EXP_MAX_VAL
```

### maxExpArray

```solidity
uint256[128] maxExpArray
```

### BancorFormula

```solidity
function BancorFormula() public
```

### power

```solidity
function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8)
```

General Description:
            Determine a value of precision.
            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.
            Return the result along with the precision used.
        Detailed Description:
            Instead of calculating &quot;base ^ exp&quot;, we calculate &quot;e ^ (log(base) * exp)&quot;.
            The value of &quot;log(base)&quot; is represented with an integer slightly smaller than &quot;log(base) * 2 ^ precision&quot;.
            The larger &quot;precision&quot; is, the more accurately this value represents the real value.
            However, the larger &quot;precision&quot; is, the more bits are required in order to store this value.
            And the exponentiation function, which takes &quot;x&quot; and calculates &quot;e ^ x&quot;, is limited to a maximum exponent (maximum value of &quot;x&quot;).
            This maximum exponent depends on the &quot;precision&quot; used, and it is given by &quot;maxExpArray[precision] &gt;&gt; (MAX_PRECISION - precision)&quot;.
            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.
            This allows us to compute &quot;base ^ exp&quot; with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.
            This functions assumes that &quot;_expN &lt; 2 ^ 256 / log(MAX_NUM - 1)&quot;, otherwise the multiplication should be replaced with a &quot;safeMul&quot;.

### generalLog

```solidity
function generalLog(uint256 x) internal pure returns (uint256)
```

Compute log(x / FIXED_1) * FIXED_1.
        This functions assumes that &quot;x &gt;&#x3D; FIXED_1&quot;, because the output would be negative otherwise.

### floorLog2

```solidity
function floorLog2(uint256 _n) internal pure returns (uint8)
```

Compute the largest integer smaller than or equal to the binary logarithm of the input.

### findPositionInMaxExpArray

```solidity
function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8)
```

The global &quot;maxExpArray&quot; is sorted in descending order, and therefore the following statements are equivalent:
        - This function finds the position of [the smallest value in &quot;maxExpArray&quot; larger than or equal to &quot;x&quot;]
        - This function finds the highest position of [a value in &quot;maxExpArray&quot; larger than or equal to &quot;x&quot;]

### generalExp

```solidity
function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256)
```

This function can be auto-generated by the script &#x27;PrintFunctionGeneralExp.py&#x27;.
        It approximates &quot;e ^ x&quot; via maclaurin summation: &quot;(x^0)/0! + (x^1)/1! + ... + (x^n)/n!&quot;.
        It returns &quot;e ^ (x / 2 ^ precision) * 2 ^ precision&quot;, that is, the result is upshifted for accuracy.
        The global &quot;maxExpArray&quot; maps each &quot;precision&quot; to &quot;((maximumExponent + 1) &lt;&lt; (MAX_PRECISION - precision)) - 1&quot;.
        The maximum permitted value for &quot;x&quot; is therefore given by &quot;maxExpArray[precision] &gt;&gt; (MAX_PRECISION - precision)&quot;.

### optimalLog

```solidity
function optimalLog(uint256 x) internal pure returns (uint256)
```

Return log(x / FIXED_1) * FIXED_1
        Input range: FIXED_1 &lt;&#x3D; x &lt;&#x3D; LOG_EXP_MAX_VAL - 1

### optimalExp

```solidity
function optimalExp(uint256 x) internal pure returns (uint256)
```

Return e ^ (x / FIXED_1) * FIXED_1
        Input range: 0 &lt;&#x3D; x &lt;&#x3D; OPT_EXP_MAX_VAL - 1

