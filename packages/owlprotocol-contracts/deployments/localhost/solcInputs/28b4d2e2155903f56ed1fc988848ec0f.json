{
  "language": "Solidity",
  "sources": {
    "contracts/assets/ERC1155/ERC1155Owl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol';\n\nimport '../../OwlBase.sol';\n\ncontract ERC1155Owl is OwlBase, ERC1155BurnableUpgradeable {\n    bytes32 private constant MINTER_ROLE = keccak256('MINTER_ROLE');\n    bytes32 private constant URI_ROLE = keccak256('URI_ROLE');\n    string private contractURI_;\n\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://ERC1155Owl/', version)));\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        string calldata uri_,\n        string calldata newContractURI,\n        address _forwarder\n    ) external initializer {\n        __ERC1155Owl_init(_admin, uri_, newContractURI, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        string calldata uri_,\n        string calldata newContractURI,\n        address _forwarder\n    ) external onlyInitializing {\n        __ERC1155Owl_init(_admin, uri_, newContractURI, _forwarder);\n    }\n\n    function __ERC1155Owl_init(\n        address _admin,\n        string memory uri_,\n        string calldata newContractURI,\n        address _forwarder\n    ) internal onlyInitializing {\n        __ERC1155_init(uri_);\n        __OwlBase_init(_admin, _forwarder);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(MINTER_ROLE, _admin);\n        _grantRole(URI_ROLE, _admin);\n\n        __ERC1155Owl_init_unchained(newContractURI);\n    }\n\n    function __ERC1155Owl_init_unchained(string calldata newContractURI) internal onlyInitializing {\n        contractURI_ = newContractURI;\n    }\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants MINTER_ROLE to {a}\n     * @param to address to\n     */\n    function grantMinter(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(MINTER_ROLE, to);\n    }\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants URI_ROLE to {a}\n     * @param to address to\n     */\n    function grantUriRole(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(URI_ROLE, to);\n    }\n\n    /***** MINTING *****/\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows MINTER_ROLE to mint NFTs\n     * @param to address to\n     * @param id tokenId value\n     * @param amount to mint\n     * @param data for hooks\n     */\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public onlyRole(MINTER_ROLE) {\n        _mint(to, id, amount, data);\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows caller to mint NFTs (safeMint)\n     * @param to address to\n     * @param ids id values\n     * @param amounts to mint\n     * @param data for hooks\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public onlyRole(MINTER_ROLE) {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @notice Must have URI_ROLE role!\n     * @dev Allows setting the uri\n     * @param newuri set the baseURI value.\n     */\n    function setURI(string calldata newuri) public onlyRole(URI_ROLE) {\n        _setURI(newuri);\n    }\n\n    /**\n     * @notice Must have URI_ROLE role!\n     * @dev Allows setting the contract uri\n     * @param newContractURI set the contractURI_ value.\n     */\n    function setContractURI(string calldata newContractURI) public onlyRole(URI_ROLE) {\n        contractURI_ = newContractURI;\n    }\n\n    /**\n     * @dev Defines collection-wide metadata that is URI-accessible\n     *\n     */\n    function contractURI() public view returns (string memory) {\n        return contractURI_;\n    }\n\n    /**\n     * @notice the following 3 functions are all required for OpenGSN integration\n     */\n    function _msgSender() internal view override(OwlBase, ContextUpgradeable) returns (address) {\n        return OwlBase._msgSender();\n    }\n\n    function _msgData() internal view override(OwlBase, ContextUpgradeable) returns (bytes calldata) {\n        return OwlBase._msgData();\n    }\n\n    /* @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/OwlBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/**\n * @dev Base for all OWLPROTOCOL contracts\n */\nabstract contract OwlBase is UUPSUpgradeable, AccessControlUpgradeable {\n    bytes32 internal constant ROUTER_ROLE = keccak256('ROUTER_ROLE');\n\n    function __OwlBase_init(address _admin, address _forwarder) internal onlyInitializing {\n        __OwlBase_init_unchained(_admin, _forwarder);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(ROUTER_ROLE, _forwarder);\n    }\n\n    function __OwlBase_init_unchained(address _admin, address _forwarder) internal onlyInitializing {}\n\n    /**\n     * @notice **REQUIRED FOR GSN**\n     * @dev Return trusted forwarder status.\n     */\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return hasRole(ROUTER_ROLE, forwarder);\n    }\n\n    /**\n     * @notice Must have owner role\n     * @dev Grants ROUTER_ROLE to {a}\n     * @param to address to\n     */\n    function grantRouter(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(ROUTER_ROLE, to);\n    }\n\n    /**\n     * UUPS functions\n     */\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    function getImplementation() external view returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice the following 3 functions are all required for OpenGSN integration\n     */\n    function _msgSender() internal view virtual override returns (address ret) {\n        if (msg.data.length >= 20 && hasRole(ROUTER_ROLE, msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            ret = msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (msg.data.length >= 20 && hasRole(ROUTER_ROLE, msg.sender)) {\n            return msg.data[0:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n\n    function versionRecipient() external pure virtual returns (string memory) {\n        return '2.2.6';\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/plugins/Crafter/CrafterCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../assets/ERC20/ERC20Owl.sol';\nimport '../../assets/ERC721/ERC721Owl.sol';\nimport '../../assets/ERC1155/ERC1155Owl.sol';\nimport '../PluginsCore.sol';\nimport './ICrafter.sol';\n\n/**\n * @dev Base contract that all Crafter contracts will inherit from\n */\nabstract contract CrafterCore is PluginsCore, ICrafter, ERC721HolderUpgradeable {\n    /**********************\n             Events\n    **********************/\n\n    event Create(address indexed creator, Ingredient[] inputs, Ingredient[] outputs);\n\n    event Update(uint256 craftableAmount);\n\n    event Craft(uint256 craftedAmount, uint256 craftableAmount, address indexed user);\n\n    /**********************\n             Storage\n    **********************/\n\n    // Address which burned items are sent to\n    address public burnAddress;\n\n    // Sets of crafts left\n    uint96 public craftableAmount;\n\n    // Array of inputs in this configurations\n    Ingredient[] private inputs;\n\n    // Array of outputs in this configurations\n    Ingredient[] internal outputs;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterCore_init(\n        address _admin,\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) internal onlyInitializing {\n        require(_burnAddress != address(0), 'CrafterCore: burn address must not be 0');\n        require(_inputs.length > 0, 'CrafterCore: A crafting input must be given!');\n        require(_outputs.length > 0, 'CrafterCore: A crafting output must be given!');\n        __OwlBase_init(_admin, _forwarder);\n\n        __CrafterCore_init_unchained(_burnAddress, _inputs, _outputs);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterCore_init_unchained(\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs\n    ) internal onlyInitializing {\n        burnAddress = _burnAddress;\n\n        // Inputs validated in __CrafterCore_init() since it is\n        // the same process for both CrafterTransfer and CrafterMint\n        _validateInputs(_inputs);\n\n        // emit Create(_msgSender(), _inputs, _outputs);\n    }\n\n    /**********************\n            Getters\n    **********************/\n\n    /**\n     * @dev Returns all inputs (without `amounts` or `tokenIds`)\n     */\n    function getInputs() public view returns (Ingredient[] memory _inputs) {\n        return inputs;\n    }\n\n    /**\n     * @dev Returns all outputs (without `amounts` or `tokenIds`)\n     */\n    function getOutputs() public view returns (Ingredient[] memory _outputs) {\n        return outputs;\n    }\n\n    /**\n     * @dev Returns all details for a specific ingredient (including\n     * amounts/tokenIds)\n     * @param index ingredient index to return details for\n     * @return token token type\n     * @return consumableType consumable type\n     * @return contractAddr token contract address\n     * @return amounts amount of each token\n     * @return tokenIds token ids\n     */\n    function getInputIngredient(uint256 index)\n        public\n        view\n        returns (\n            TokenType token,\n            ConsumableType consumableType,\n            address contractAddr,\n            uint256[] memory amounts,\n            uint256[] memory tokenIds\n        )\n    {\n        Ingredient storage i = inputs[index];\n\n        return (i.token, i.consumableType, i.contractAddr, i.amounts, i.tokenIds);\n    }\n\n    /**\n     * @dev Returns all details for a specific ingredient (including\n     * amounts/tokenIds)\n     * @param index ingredient index to return details for\n     * @return token token type\n     * @return consumableType consumable type\n     * @return contractAddr token contract address\n     * @return amounts amount of each token\n     * @return tokenIds token ids\n     */\n    function getOutputIngredient(uint256 index)\n        public\n        view\n        returns (\n            TokenType token,\n            ConsumableType consumableType,\n            address contractAddr,\n            uint256[] memory amounts,\n            uint256[] memory tokenIds\n        )\n    {\n        Ingredient storage i = outputs[index];\n\n        return (i.token, i.consumableType, i.contractAddr, i.amounts, i.tokenIds);\n    }\n\n    /**********************\n           Utilities\n    **********************/\n\n    /**\n     * @dev calls PluginsCore._validateInputs(_inputs, inputs)\n     */\n    function _validateInputs(Ingredient[] calldata _inputs) internal {\n        super._validateInputs(_inputs, inputs);\n    }\n\n    /**\n     * @dev call PluginsCore._useInputs(inputs, from, burnAddress,\n     * _inputERC721Ids, amount)\n     */\n    function _useInputs(uint256[][] calldata _inputERC721Ids, uint256 amount) internal {\n        super._useInputs(inputs, _msgSender(), burnAddress, _inputERC721Ids, amount);\n    }\n\n    /**\n     * @dev validates outputs array of ingredients\n     * @param _outputs the output array of the Crafter initializer\n     * @param _craftableAmount the amount of times the recipe may be crafted\n     */\n    function _validateOutputs(PluginsCore.Ingredient[] memory _outputs, uint256 _craftableAmount)\n        internal\n        returns (uint256)\n    {\n        uint256 erc721Amount = 0;\n        for (uint256 i = 0; i < _outputs.length; i++) {\n            if (_outputs[i].token == PluginsCore.TokenType.erc20) {\n                require(_outputs[i].tokenIds.length == 0, 'CrafterCore: tokenids.length != 0');\n                require(_outputs[i].amounts.length == 1, 'CrafterCore: amounts.length != 1');\n                outputs.push(_outputs[i]);\n            } else if (_outputs[i].token == PluginsCore.TokenType.erc721) {\n                require(\n                    _outputs[i].tokenIds.length == _craftableAmount,\n                    'CrafterCore: tokenids.length != _craftableAmount'\n                );\n                require(_outputs[i].amounts.length == 0, 'CrafterCore: amounts.length != 0');\n                erc721Amount++;\n\n                // Copy token data but set tokenIds as empty (these are filled\n                // out in the _deposit function call)\n                PluginsCore.Ingredient memory x = PluginsCore.Ingredient({\n                    token: PluginsCore.TokenType.erc721,\n                    consumableType: _outputs[i].consumableType,\n                    contractAddr: _outputs[i].contractAddr,\n                    amounts: new uint256[](0),\n                    tokenIds: new uint256[](0)\n                });\n                outputs.push(x);\n            } else {\n                // Solidity compiler ensures this is TokenType 1155\n                require(\n                    _outputs[i].tokenIds.length == _outputs[i].amounts.length,\n                    'CrafterCore: tokenids.length != amounts.length'\n                );\n                outputs.push(_outputs[i]);\n            }\n        }\n\n        return erc721Amount;\n    }\n\n    /**\n     * @dev Creating a static 2d array\n     * @param _outputs the output array of the Crafter initializer\n     * @param _craftableAmount the amount of times the recipe may be crafted\n     * @param erc721Amount the number of erc721 tokens to be used as output\n     */\n    function _createOutputsArr(\n        PluginsCore.Ingredient[] memory _outputs,\n        uint256 _craftableAmount,\n        uint256 erc721Amount\n    ) internal pure returns (uint256[][] memory) {\n        uint256[][] memory _outputsERC721Ids = new uint256[][](erc721Amount);\n        uint256 outputERC721index = 0;\n\n        for (uint256 i = 0; i < _outputs.length; i++) {\n            if (_outputs[i].token == PluginsCore.TokenType.erc721) {\n                _outputsERC721Ids[outputERC721index] = new uint256[](_craftableAmount);\n                for (uint256 j = 0; j < _craftableAmount; j++) {\n                    _outputsERC721Ids[outputERC721index][j] = _outputs[i].tokenIds[j];\n                }\n                outputERC721index++;\n            }\n        }\n\n        return _outputsERC721Ids;\n    }\n\n    /**\n     * @dev function must be overriden by child contract. Adding\n     * process is too different between the contract for\n     * abstraction\n     * @param amount sets of outputs to deposit\n     * @param _outputsERC721Ids erc721 `tokenId`s to use as outputs\n     * @param from if transferring, address to transfer outputs from\n     */\n    function _addOutputs(\n        uint256 amount,\n        uint256[][] memory _outputsERC721Ids,\n        address from\n    ) internal virtual;\n\n    /**\n     * @dev function must be overriden by child contract. Removal\n     * process is too different between the contracts for\n     * abstraction\n     * @param amount sets of outputs to remove\n     * @param to address to send outputs to\n     */\n    function _removeOutputs(uint96 amount, address to) internal virtual;\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/assets/ERC20/ERC20Owl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol';\n\nimport '../../OwlBase.sol';\n\ncontract ERC20Owl is OwlBase, ERC20BurnableUpgradeable {\n    bytes32 private constant MINTER_ROLE = keccak256('MINTER_ROLE');\n    bytes32 private constant URI_ROLE = keccak256('URI_ROLE');\n\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://ERC20Owl/', version)));\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        address _forwarder\n    ) external initializer {\n        __ERC20Owl_init(_admin, _name, _symbol, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        address _forwarder\n    ) external onlyInitializing {\n        __ERC20Owl_init(_admin, _name, _symbol, _forwarder);\n    }\n\n    function __ERC20Owl_init(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        address _forwarder\n    ) internal onlyInitializing {\n        __ERC20_init(_name, _symbol);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(MINTER_ROLE, _admin);\n\n        __ERC20Owl_init_unchained(_admin, _forwarder);\n    }\n\n    function __ERC20Owl_init_unchained(address _admin, address _forwarder) internal onlyInitializing {}\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants MINTER_ROLE to {a}\n     * @param to address to\n     */\n    function grantMinter(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(MINTER_ROLE, to);\n    }\n\n    /***** MINTING *****/\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows MINTER_ROLE to mint NFTs\n     * @param to address to\n     * @param amount amount to mint\n     */\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function _msgSender() internal view override(OwlBase, ContextUpgradeable) returns (address) {\n        return OwlBase._msgSender();\n    }\n\n    function _msgData() internal view virtual override(OwlBase, ContextUpgradeable) returns (bytes calldata) {\n        return OwlBase._msgData();\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/assets/ERC721/ERC721Owl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol';\n\nimport '../../OwlBase.sol';\n\n/**\n * @dev This implements the standard OwlProtocol `ERC721` contract that is an\n * extension of Openzeppelin's `ERC721BurnableUpgradeable`. Initializations\n * happens through initializers for compatibility with a EIP1167 minimal-proxy\n * deployment strategy.\n */\ncontract ERC721Owl is OwlBase, ERC721BurnableUpgradeable {\n    bytes32 internal constant MINTER_ROLE = keccak256('MINTER_ROLE');\n    bytes32 internal constant URI_ROLE = keccak256('URI_ROLE');\n\n    string public constant VERSION = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://ERC721Owl/', VERSION)));\n\n    /**********************\n           Storage\n    **********************/\n\n    string public baseURI;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes an ERC721Owl contract\n     * @param _admin admin for contract\n     * @param _name name for contract\n     * @param _symbol symbol for contract\n     * @param baseURI_ base URI for contract\n     * @param _forwarder address for trusted forwarder for open GSN\n     */\n    function initialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external virtual initializer {\n        __ERC721Owl_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external virtual onlyInitializing {\n        __ERC721Owl_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    function __ERC721Owl_init(\n        address _admin,\n        string memory _name,\n        string memory _symbol,\n        string memory baseURI_,\n        address _forwarder\n    ) internal onlyInitializing {\n        __ERC721_init(_name, _symbol);\n        __OwlBase_init(_admin, _forwarder);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(MINTER_ROLE, _admin);\n        _grantRole(URI_ROLE, _admin);\n\n        __ERC721Owl_init_unchained(baseURI_);\n    }\n\n    function __ERC721Owl_init_unchained(string memory baseURI_) internal onlyInitializing {\n        (_msgData());\n        baseURI = baseURI_;\n    }\n\n    /**********************\n          Interaction\n    **********************/\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants MINTER_ROLE to `to`\n     * @param to address tos\n     */\n    function grantMinter(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(MINTER_ROLE, to);\n    }\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants URI_ROLE to `a`\n     * @param to address to\n     */\n    function grantUriRole(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(URI_ROLE, to);\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows MINTER_ROLE to mint NFTs\n     * @param to address to\n     * @param tokenId tokenId value\n     */\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows caller to mint NFTs (safeMint)\n     * @param to address to\n     * @param tokenId tokenId value\n     */\n    function safeMint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _safeMint(to, tokenId);\n    }\n\n    /**\n     * @notice Must have URI_ROLE role!\n     * @dev Allows setting the baseURI\n     * @param baseURI_ set the baseURI value.\n     */\n    function setBaseURI(string calldata baseURI_) public onlyRole(URI_ROLE) {\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Overrides OZ internal baseURI getter.\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev Returns collection-wide URI-accessible metadata\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(baseURI, 'metadata.json'));\n    }\n\n    /**\n     * @dev exposing `_exists`\n     */\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev use {OwlBase._msgSender()}\n     */\n    function _msgSender() internal view override(OwlBase, ContextUpgradeable) returns (address) {\n        return OwlBase._msgSender();\n    }\n\n    /**\n     * @dev use {OwlBase._msgData()}\n     */\n    function _msgData() internal view override(OwlBase, ContextUpgradeable) returns (bytes calldata) {\n        return OwlBase._msgData();\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/plugins/PluginsCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\n\n/**\n * @dev Abstract contract with types and utilities that will be used by many (if\n * not all) Plugins contracts\n *\n *\n */\nabstract contract PluginsCore is OwlBase {\n    event RouterError(uint256 indexed routeId, address indexed sender, bytes indexed data);\n\n    // Unaffected inputs of this type are unaffected by the crafting process.\n    // DOES NOT APPLY TO ERC 721 INPUTS, USE NTime INSTEAD.\n    // Burned inputs of this type are burned during the crafting process/\n    // NTime inputs of this type are not burned, but can only be used N times in\n    // the same recipe; Only available for ERC721 TokenType\n    enum ConsumableType {\n        unaffected,\n        burned,\n        NTime\n    }\n\n    // Current set of support token types as assets\n    enum TokenType {\n        erc20,\n        erc721,\n        erc1155\n    }\n\n    struct Ingredient {\n        TokenType token;\n        ConsumableType consumableType;\n        address contractAddr;\n        uint256[] amounts;\n        uint256[] tokenIds;\n    }\n\n    // mapping from ingredient to nUSE (max count grabbed from amounts[0])\n    mapping(uint256 => uint256) nUse;\n\n    // mapping from contract address to tokenId to nUsed\n    mapping(address => mapping(uint256 => uint256)) usedERC721Inputs;\n\n    /**\n     * @dev will use/consume inputs as dicatated by the configuration\n     * @param inputs set of inputs in the configuration\n     * @param from address to use/consume inputs from\n     * @param burnAddress in case configuration requires a burn\n     * address to transfer items to\n     * @param _inputERC721Ids set of ERC721 `tokenId`s, if applicable\n     * Example of `_inputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `inputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     * @param amount sets of inputs to use/consume\n     */\n    function _useInputs(\n        Ingredient[] storage inputs,\n        address from,\n        address burnAddress,\n        uint256[][] calldata _inputERC721Ids,\n        uint256 amount\n    ) internal {\n        // Keep count of the amount of erc721Inputs so if there\n        // are multiple `tokenId`s in `_inputsERC721Ids`, next\n        // element in the array is only used when iteration is\n        // at next ERC721\n        uint256 erc721Inputs = 0;\n\n        for (uint256 i = 0; i < inputs.length; i++) {\n            Ingredient storage ingredient = inputs[i];\n            if (ingredient.token == TokenType.erc20) {\n                if (ingredient.consumableType == ConsumableType.burned) {\n                    SafeERC20Upgradeable.safeTransferFrom(\n                        IERC20Upgradeable(ingredient.contractAddr),\n                        from,\n                        burnAddress,\n                        ingredient.amounts[0] * amount\n                    );\n                } else {\n                    // this is unaffected, as ensured by input validations\n                    require(\n                        IERC20Upgradeable(ingredient.contractAddr).balanceOf(from) >= ingredient.amounts[0] * amount,\n                        'PluginsCore: User missing minimum token balance(s)!'\n                    );\n                }\n            } else if (ingredient.token == TokenType.erc721) {\n                uint256[] memory currInputArr = _inputERC721Ids[erc721Inputs];\n                require(currInputArr.length == amount, 'PluginsCore: _inputERC721Ids[i] != amount');\n                if (ingredient.consumableType == ConsumableType.burned) {\n                    for (uint256 j = 0; j < currInputArr.length; j++) {\n                        IERC721Upgradeable(ingredient.contractAddr).safeTransferFrom(\n                            from,\n                            burnAddress,\n                            currInputArr[j]\n                        );\n                    }\n                } else {\n                    //this is N-time, as ensured by input validations\n                    for (uint256 j = 0; j < currInputArr.length; j++) {\n                        require(\n                            IERC721Upgradeable(ingredient.contractAddr).ownerOf(currInputArr[j]) == from,\n                            'PluginsCore: User does not own token(s)!'\n                        );\n                        uint256 currTokenId = currInputArr[j];\n                        require(\n                            (usedERC721Inputs[ingredient.contractAddr])[currTokenId] < nUse[i],\n                            'PluginsCore: Used over the limit of n'\n                        );\n                        (usedERC721Inputs[ingredient.contractAddr])[currTokenId] += 1;\n                    }\n                }\n                erc721Inputs += 1;\n            } else {\n                // this is 1155 token type, as ensured by input validations\n                if (ingredient.consumableType == ConsumableType.burned) {\n                    uint256[] memory amounts = new uint256[](ingredient.amounts.length);\n                    for (uint256 j = 0; j < ingredient.amounts.length; j++) {\n                        amounts[j] = ingredient.amounts[j] * amount;\n                    }\n                    IERC1155Upgradeable(ingredient.contractAddr).safeBatchTransferFrom(\n                        from,\n                        burnAddress,\n                        ingredient.tokenIds,\n                        amounts,\n                        new bytes(0)\n                    );\n                } else {\n                    //this is unaffected consumable type, as ensured by input validations\n                    uint256[] memory amounts = new uint256[](ingredient.amounts.length);\n                    address[] memory accounts = new address[](ingredient.amounts.length);\n                    for (uint256 j = 0; j < ingredient.amounts.length; j++) {\n                        amounts[j] = ingredient.amounts[j] * amount;\n                        accounts[j] = from;\n                    }\n\n                    uint256[] memory balances = IERC1155Upgradeable(ingredient.contractAddr).balanceOfBatch(\n                        accounts,\n                        ingredient.tokenIds\n                    );\n                    for (uint256 j = 0; j < balances.length; j++) {\n                        require(balances[j] >= amounts[j], 'PluginsCore: User missing minimum token balance(s)!');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev validates inputs array of ingredients\n     * @param _inputs the inputted array to the Crafter initializer\n     * @param inputs storage array of inputs, copied from _inputs\n     */\n    function _validateInputs(Ingredient[] calldata _inputs, Ingredient[] storage inputs) internal {\n        for (uint256 i = 0; i < _inputs.length; i++) {\n            TokenType token = _inputs[i].token;\n            if (token == TokenType.erc20) {\n                require(_inputs[i].tokenIds.length == 0, 'PluginsCore: tokenids.length != 0');\n                require(_inputs[i].amounts.length == 1, 'PluginsCore: amounts.length != 1');\n                require(\n                    _inputs[i].consumableType == ConsumableType.unaffected ||\n                        _inputs[i].consumableType == ConsumableType.burned,\n                    'PluginsCore: ERC20 consumableType not unaffected or burned'\n                );\n            } else if (token == TokenType.erc721) {\n                //accept all token ids as inputs\n                require(_inputs[i].tokenIds.length == 0, 'PluginsCore: tokenIds.length != 0');\n                require(\n                    _inputs[i].consumableType == ConsumableType.burned ||\n                        _inputs[i].consumableType == ConsumableType.NTime,\n                    'PluginsCore: ERC721 consumableType not burned or NTime'\n                );\n\n                if (_inputs[i].consumableType == ConsumableType.NTime) {\n                    require(\n                        _inputs[i].amounts.length == 1,\n                        'PluginsCore: amounts.length != 1; required for NTime ConsumableType'\n                    );\n\n                    nUse[i] = _inputs[i].amounts[0];\n                } else require(_inputs[i].amounts.length == 0, 'PluginsCore: amounts.length != 0');\n            } else {\n                // Solidity compiler ensures this is TokenType 1155\n                require(\n                    _inputs[i].tokenIds.length == _inputs[i].amounts.length,\n                    'PluginsCore: tokenids.length != amounts.length'\n                );\n                require(\n                    _inputs[i].consumableType == ConsumableType.unaffected ||\n                        _inputs[i].consumableType == ConsumableType.burned,\n                    'PluginsCore: ERC1155 consumableType not unaffected or burned'\n                );\n            }\n\n            inputs.push(_inputs[i]);\n        }\n    }\n\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/plugins/Crafter/ICrafter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../PluginsCore.sol';\n\n/**\n * @dev Crafting contracts interface\n */\ninterface ICrafter {\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner, can control outputs on contract\n     * @param _burnAddress Burn address for burn inputs\n     * @param _craftableAmount limit on the number of times this configuration\n     * can be crafted\n     * @param _inputs inputs for configuration\n     * @param _outputs outputs for configuration\n     * @param _forwarder trusted forwarder address for openGSN\n     */\n    function initialize(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        PluginsCore.Ingredient[] calldata _inputs,\n        PluginsCore.Ingredient[] calldata _outputs,\n        address _forwarder\n    ) external;\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`. Automatically sends from\n     * `_msgSender()`\n     * @dev Used to deposit configuration outputs.\n     * @param amount How many more times the configuration should be\n     * craftable\n     * @param _outputsERC721Ids 2D-array of ERC721 tokens used in crafting\n     * Example of `_outputERC721Ids` with `amount = 2` with 3\n     * `Ingredient`s\n     * in `outputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function deposit(uint96 amount, uint256[][] calldata _outputsERC721Ids) external;\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`\n     * @dev Used to withdraw configuration outputs out of contract to the\n     * caller. Will also decrease `craftableAmount`\n     * @param amount How many sets of outputs should be withdrawn\n     */\n    function withdraw(uint96 amount) external;\n\n    /**\n     * @notice Craft `amount`\n     * @dev Used to craft. Consumes inputs and transfers outputs.\n     * @param amount How many times to craft\n     * @param _inputERC721Ids Array of pre-approved NFTs for crafting usage.\n     * Example of `_inputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `inputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function craft(uint96 amount, uint256[][] calldata _inputERC721Ids) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/plugins/Crafter/CrafterTransfer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './CrafterCore.sol';\n\n/**\n * @dev Contract module that enables crafting of different types of assets\n * (ERC20, ERC721, ERC1155) whose crafting outputs are transferred to the\n * caller.\n *\n * Crafting configuration is designated by two {Ingredient}[]. One array is the\n * `inputs` and the other is the `outputs`. The contract allows for the `inputs`\n * to be redeemed for the `outputs`, `craftableAmount` times.\n *\n * ```\n * struct Ingredient {\n *     TokenType token;\n *     ConsumableType consumableType;\n *     address contractAddr;\n *     uint256[] amounts;\n *     uint256[] tokenIds;\n * }\n * ```\n *\n * Configuration is set in the initializers and cannot be edited once the\n * contract has been launched Other configurations will require their own\n * contract to be deployed\n *\n * However, `craftableAmount` can be dynamically updated through the {deposit}\n * and {withdraw} functions which are only accessible to `DEFAULT_ADMIN_ROLE`\n *\n * Each Ingredient has a `consumableType` field. This field is for the `inputs`\n * elements and ignored by the `outputs` elements. ERC20 and ERC1155 `inputs`\n * elements can be `unaffected` or `burned`. `unaffected` will check for\n * ownership/balance while `burned` will send the asset(s) to the `burnAddress`.\n * ERC721 inputs can be `NTime` or `burned`. `NTime` allows for a specfic\n * `tokenId` to only be used 'n times', as defined by contract deployer.\n *\n * ERC20 `inputs` and `outputs` elements should have one number in the `amounts`\n * array denoting ERC20 token amount requirement.* `tokenIds` should be empty.\n *\n * NTime consumable type ERC721 inputs should have empty `tokenIds` and\n * `amounts[0]` equal to `n` - the maximum number of times the input can be\n * used.* Burned ERC721 `inputs` elements should have * empty `amounts` and\n * `tokenIds` array. This contract accepts *all* `tokenId`s from an ERC721\n * contract as inputs. ERC721 `outputs` elements must have empty `amounts`\n * array. `tokenIds` array length should be `craftableAmount`. The `tokenIds`\n * array will contain the `tokenIds` to be transferred out when {craft} is\n * called. Important to note that output transfers will be from the *end* of the\n * array since `.pop()` is used.\n *\n * ERC1155 `inputs` and `outputs` elements should have the length of `amounts`\n * and `tokenIds` array be the same. The indices will be linked where each index\n * denotes how much of each ERC1155 `tokenId` is required.\n *\n * A note on depositing and initialization: depositer/`_admin` must hold a\n * `craftableAmount` of the outputs or the call will fail.\n *\n * This module is used through composition. It can be deployed to create\n * crafting logic with asset contracts that are already on chain and active;\n * plug-and-play, so to speak.\n */\ncontract CrafterTransfer is CrafterCore, ERC1155HolderUpgradeable {\n    string public constant VERSION = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://CrafterTransfer/', VERSION)));\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner, can control outputs on contract\n     * @param _burnAddress Burn address for burn inputs\n     * @param _craftableAmount limit on the number of times this configuration\n     * can be crafted\n     * @param _inputs inputs for configuration\n     * @param _outputs outputs for configuration\n     * @param _forwarder trusted forwarder address for openGSN\n     */\n    function initialize(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) external initializer {\n        __CrafterTransfer_init(_admin, _burnAddress, _craftableAmount, _inputs, _outputs, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) external onlyInitializing {\n        __CrafterTransfer_init(_admin, _burnAddress, _craftableAmount, _inputs, _outputs, _forwarder);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterTransfer_init(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) internal onlyInitializing {\n        __CrafterCore_init(_admin, _burnAddress, _inputs, _outputs, _forwarder);\n\n        __CrafterTransfer_init_unchained(_admin, _craftableAmount, _outputs);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterTransfer_init_unchained(\n        address _admin,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _outputs\n    ) internal onlyInitializing {\n        uint256 erc721Amount = _validateOutputs(_outputs, _craftableAmount);\n\n        uint256[][] memory _outputsERC721Ids = _createOutputsArr(_outputs, _craftableAmount, erc721Amount);\n        if (_craftableAmount > 0) _deposit(_craftableAmount, _outputsERC721Ids, _admin);\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`. Automatically sends from\n     * `_msgSender()`\n     * @dev Used to deposit configuration outputs.\n     * @param amount How many more times the configuration should be\n     * craftable\n     * @param _outputsERC721Ids 2D-array of ERC721 tokens used in crafting\n     * Example of `_outputERC721Ids` with `amount = 2` with 3\n     * `Ingredient`s\n     * in `outputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function deposit(uint96 amount, uint256[][] calldata _outputsERC721Ids) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _deposit(amount, _outputsERC721Ids, _msgSender());\n    }\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`\n     * @dev Used to deposit configuration outputs. This is only ever directly\n     * called in intializations.\n     * @param amount How many times the configuration should be craftable\n     * @param _outputsERC721Ids 2D-array of ERC721 tokens used in crafting\n     * @param from address to transfer tokens from\n     */\n    function _deposit(\n        uint96 amount,\n        uint256[][] memory _outputsERC721Ids,\n        address from\n    ) internal {\n        require(amount > 0, 'CrafterTransfer: amount cannot be 0!');\n\n        craftableAmount += amount;\n\n        _addOutputs(amount, _outputsERC721Ids, from);\n\n        emit Update(craftableAmount);\n    }\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`\n     * @dev Used to withdraw configuration outputs out of contract to the\n     * caller. Will also decrease `craftableAmount`\n     * @param amount How many sets of outputs should be withdrawn\n     */\n    function withdraw(uint96 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Will take outputs out of contract and transfer\n        // them to caller\n        _removeOutputs(amount, _msgSender());\n\n        emit Update(craftableAmount);\n    }\n\n    /**\n     * @notice Craft `amount`\n     * @dev Used to craft. Consumes inputs and transfers outputs.\n     * @param amount How many times to craft\n     * @param _inputERC721Ids Array of pre-approved NFTs for crafting usage.\n     * Example of `_inputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `inputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function craft(uint96 amount, uint256[][] calldata _inputERC721Ids) external {\n        // This will remove a `withdrawAmount` of outputs and ERC721 `tokenId`\n        // by transferring to the _msgSender()\n        _removeOutputs(amount, _msgSender());\n\n        _useInputs(_inputERC721Ids, amount);\n\n        emit Craft(amount, craftableAmount, _msgSender());\n    }\n\n    /**\n     * @dev adds outputs to the contract balances and transfers the outputs into\n     * the contract\n     * @param amount sets of outputs to add\n     * @param _outputsERC721Ids if there are ERC721 tokens present, supply their\n     * `tokenId`s\n     * Example of `_outputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `outputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     * @param from address to transfer assets from\n     */\n    function _addOutputs(\n        uint256 amount,\n        uint256[][] memory _outputsERC721Ids,\n        address from\n    ) internal override {\n        // Keep count of the amount of erc721Outputs so if there are multiple\n        // `tokenId`s in `_outputsERC721Ids`, next element in the array is only\n        // used when iteration is at next ERC721\n        uint256 erc721Outputs = 0;\n\n        // Go through all `PluginsCore.Ingredient`s in `outputs` and call\n        // appropriate function to transfer the outputs in from `from`\n        for (uint256 i = 0; i < outputs.length; i++) {\n            PluginsCore.Ingredient storage ingredient = outputs[i];\n            if (ingredient.token == PluginsCore.TokenType.erc20) {\n                IERC20Upgradeable(ingredient.contractAddr).transferFrom(\n                    from,\n                    address(this),\n                    ingredient.amounts[0] * amount\n                );\n            } else if (ingredient.token == PluginsCore.TokenType.erc721) {\n                require(\n                    _outputsERC721Ids[erc721Outputs].length == amount,\n                    'CrafterTransfer: _outputsERC721Ids[i] != amount'\n                );\n                for (uint256 j = 0; j < _outputsERC721Ids[erc721Outputs].length; j++) {\n                    IERC721Upgradeable(ingredient.contractAddr).safeTransferFrom(\n                        from,\n                        address(this),\n                        _outputsERC721Ids[erc721Outputs][j]\n                    );\n\n                    //Update ingredient `tokenIds`, push additional ERC721 tokenId\n                    ingredient.tokenIds.push(_outputsERC721Ids[erc721Outputs][j]);\n                }\n                erc721Outputs += 1;\n            } else {\n                // This is TokenType ERC1155 by way of validateOutputs\n                uint256[] memory amounts = new uint256[](ingredient.amounts.length);\n\n                // Calculate amount of each `tokenId` to transfer\n                for (uint256 j = 0; j < ingredient.amounts.length; j++) {\n                    amounts[j] = ingredient.amounts[j] * amount;\n                }\n\n                // Use batch transfer to save gas\n                IERC1155Upgradeable(ingredient.contractAddr).safeBatchTransferFrom(\n                    from,\n                    address(this),\n                    ingredient.tokenIds,\n                    amounts,\n                    new bytes(0)\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev removes outputs from contract balances and send the assets to\n     * address `to`\n     * @param amount sets of outputs to remove\n     * @param to address to send outputs to\n     */\n    function _removeOutputs(uint96 amount, address to) internal override {\n        require(amount > 0, 'CrafterTransfer: amount cannot be 0!');\n        require(amount <= craftableAmount, 'CrafterTransfer: Not enough resources to craft!');\n\n        craftableAmount -= amount;\n\n        for (uint256 i = 0; i < outputs.length; i++) {\n            PluginsCore.Ingredient storage ingredient = outputs[i];\n            if (ingredient.token == PluginsCore.TokenType.erc20)\n                IERC20Upgradeable(ingredient.contractAddr).transfer(to, ingredient.amounts[0] * amount);\n            else if (ingredient.token == PluginsCore.TokenType.erc721) {\n                for (uint256 j = 0; j < amount; j++) {\n                    IERC721Upgradeable(ingredient.contractAddr).safeTransferFrom(\n                        address(this),\n                        to,\n                        ingredient.tokenIds[ingredient.tokenIds.length - 1]\n                    );\n\n                    // Pop `tokenId`s from the back\n                    ingredient.tokenIds.pop();\n                }\n            } else {\n                //ERC1155, by way of validate inputs\n                uint256[] memory amounts = new uint256[](ingredient.amounts.length);\n                for (uint256 j = 0; j < ingredient.amounts.length; j++) {\n                    amounts[j] = ingredient.amounts[j] * amount;\n                }\n\n                IERC1155Upgradeable(ingredient.contractAddr).safeBatchTransferFrom(\n                    address(this),\n                    to,\n                    ingredient.tokenIds,\n                    amounts,\n                    new bytes(0)\n                );\n            }\n        }\n    }\n\n    /**********************\n            ERC165\n    **********************/\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/plugins/Crafter/CrafterMint.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './CrafterCore.sol';\n\n/**\n * @dev Contract module that enables crafting of different types of assets\n * (ERC20, ERC721, ERC1155) whose crafting outputs are minted to the caller.\n *\n * Crafting configuration is designated by two {Ingredient}[]. One array is the\n * `inputs` and the other is the `outputs`. The contract allows for the `inputs`\n * to be redeemed for the `outputs`, `craftableAmount` times.\n *\n * ```\n * struct Ingredient {\n *     TokenType token;\n *     ConsumableType consumableType;\n *     address contractAddr;\n *     uint256[] amounts;\n *     uint256[] tokenIds;\n * }\n * ```\n *\n * Configuration is set in the initializers and cannot be edited once the\n * contract has been launched Other configurations will require their own\n * contract to be deployed\n *\n * However, `craftableAmount` can be dynamically updated through the {deposit}\n * and {withdraw} functions which are only accessible to `DEFAULT_ADMIN_ROLE`\n *\n * Each Ingredient has a `consumableType` field.* This field is for the `inputs`\n * elements and ignored by the `outputs` elements. ERC20 and ERC1155 `inputs`\n * elements can be `unaffected` or `burned`. `unaffected` will check for\n * ownership/balance while `burned` will send the asset(s) to the `burnAddress`.\n * ERC721 inputs can be `NTime` or `burned`. `NTime` allows for a specfic\n * `tokenId` to only be used 'n times', as defined by contract deployer.\n *\n * ERC20 `inputs` and `outputs` elements should have one number in the `amounts`\n * array denoting ERC20 token amount requirement.* `tokenIds` should be empty.\n *\n * NTime consumable type ERC721 inputs should have empty `tokenIds` and\n * `amounts[0]` equal to `n` - the maximum number of times the input can be\n * used.* Burned ERC721 `inputs` elements should have * empty `amounts` and\n * `tokenIds` array. This contract accepts *all* `tokenId`s from an ERC721\n * contract as inputs. ERC721 `outputs` elements must have empty `amounts`\n * array. `tokenIds` array length should be `craftableAmount`. The `tokenIds`\n * array will contain the `tokenIds` to be transferred out when {craft} is\n * called. Important to note that output transfers will be from the *end* of the\n * array since `.pop()` is used.\n *\n * ERC1155 `inputs` and `outputs` elements should have the length of `amounts`\n * and `tokenIds` array be the same. The indices will be linked where each index\n * denotes how much of each ERC1155 `tokenId` is required.\n *\n * This module is used through composition. It can be deployed to create\n * crafting logic with asset contracts that are already on chain and active;\n * plug-and-play, so to speak.\n */\ncontract CrafterMint is CrafterCore, ERC1155HolderUpgradeable {\n    string public constant VERSION = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://CrafterMint/', VERSION)));\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner, can control outputs on contract\n     * @param _burnAddress Burn address for burn inputs\n     * @param _craftableAmount limit on the number of times this configuration\n     * can be crafted\n     * @param _inputs inputs for configuration\n     * @param _outputs outputs for configuration\n     * @param _forwarder trusted forwarder address for openGSN\n     */\n    function initialize(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) external initializer {\n        __CrafterMint_init(_admin, _burnAddress, _craftableAmount, _inputs, _outputs, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) external onlyInitializing {\n        __CrafterMint_init(_admin, _burnAddress, _craftableAmount, _inputs, _outputs, _forwarder);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterMint_init(\n        address _admin,\n        address _burnAddress,\n        uint96 _craftableAmount,\n        Ingredient[] calldata _inputs,\n        Ingredient[] calldata _outputs,\n        address _forwarder\n    ) internal onlyInitializing {\n        __CrafterCore_init(_admin, _burnAddress, _inputs, _outputs, _forwarder);\n\n        __CrafterMint_init_unchained(_craftableAmount, _outputs);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __CrafterMint_init_unchained(uint96 _craftableAmount, Ingredient[] calldata _outputs)\n        internal\n        onlyInitializing\n    {\n        uint256 erc721Amount = _validateOutputs(_outputs, _craftableAmount);\n\n        uint256[][] memory _outputsERC721Ids = _createOutputsArr(_outputs, _craftableAmount, erc721Amount);\n        if (_craftableAmount > 0) _deposit(_craftableAmount, _outputsERC721Ids);\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`.\n     * @dev Used to deposit configuration outputs.\n     * @param amount How many more times the configuration should be\n     * craftable\n     * @param _outputsERC721Ids 2D-array of ERC721 tokens used in crafting\n     * Example of `_outputERC721Ids` with `amount = 2` with 3\n     * `Ingredient`s\n     * in `outputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function deposit(uint96 amount, uint256[][] calldata _outputsERC721Ids) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _deposit(amount, _outputsERC721Ids);\n    }\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`\n     * @dev Used to deposit configuration outputs. This is only ever directly\n     * called in intializations.\n     * @param amount How many times the configuration should be craftable\n     * @param _outputsERC721Ids 2D-array of ERC721 tokens used in crafting\n     */\n    function _deposit(uint96 amount, uint256[][] memory _outputsERC721Ids) internal {\n        require(amount > 0, 'CrafterMint: amount cannot be 0!');\n        craftableAmount += amount;\n\n        // address `from` parameter irrelevant in CrafterMint... passing\n        // 0 address will suffice\n        _addOutputs(amount, _outputsERC721Ids, address(0));\n\n        emit Update(craftableAmount);\n    }\n\n    /**\n     * @notice Must be `DEFAULT_ADMIN_ROLE`\n     * @dev Used to withdraw configuration outputs out of contract by decreasing\n     * `craftableAmount`.\n     * @param amount How many sets of outputs should be withdrawn\n     */\n    function withdraw(uint96 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // This will remove a `amount` of outputs and ERC721 `tokenId`\n        // without doing any minting\n        _removeOutputs(amount, address(0));\n\n        emit Update(craftableAmount);\n    }\n\n    /**\n     * @notice Craft `amount`\n     * @dev Used to craft. Consumes inputs and mints outputs.\n     * @param amount How many times to craft\n     * @param _inputERC721Ids Array of pre-approved NFTs for crafting usage.\n     * Example of `_inputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `inputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function craft(uint96 amount, uint256[][] calldata _inputERC721Ids) external {\n        // This will remove a `amount` of outputs and ERC721 `tokenId`\n        // while also minting to the _msgSender()\n        _removeOutputs(amount, _msgSender());\n\n        _useInputs(_inputERC721Ids, amount);\n\n        emit Craft(amount, craftableAmount, _msgSender());\n    }\n\n    /**\n     * @dev adds outputs to the contract balances\n     * @param amount sets of outputs to add\n     * @param _outputsERC721Ids if there are ERC721 tokens present, supply their\n     * `tokenId`s\n     * Example of `_outputERC721Ids` with `amount = 2` with 3 `Ingredient`s\n     * in `outputs` with `TokenType.ERC721`\n     * ```\n     * [\n     *  [1, 2]\n     *  [3, 4]\n     *  [5, 6]\n     * ]\n     * ```\n     */\n    function _addOutputs(\n        uint256 amount,\n        uint256[][] memory _outputsERC721Ids,\n        address /* from */\n    ) internal override {\n        // Keep count of the amount of erc721Outputs so if there\n        // are multiple `tokenId`s in `_outputsERC721Ids`, next\n        // element in the array is only used when iteration is\n        // at next ERC721\n        uint256 erc721Outputs = 0;\n\n        // Go through all `PluginsCore.Ingredient`s in `outputs` and\n        // find ERC721 outputs. Then update `tokenId`s in ERC721 `Ingredient`s\n        //  inside the `outputs` array. ERC20 and ERC1155 changes do\n        //  not need to be made as their balances are only dependent on the\n        // `craftableAmount` variable\n        for (uint256 i = 0; i < outputs.length; i++) {\n            PluginsCore.Ingredient storage ingredient = outputs[i];\n            if (ingredient.token == PluginsCore.TokenType.erc721) {\n                require(\n                    _outputsERC721Ids[erc721Outputs].length == amount,\n                    'CrafterMint: _outputsERC721Ids[i] != amount'\n                );\n                for (uint256 j = 0; j < _outputsERC721Ids[erc721Outputs].length; j++) {\n                    require(\n                        !ERC721Owl(ingredient.contractAddr).exists(_outputsERC721Ids[erc721Outputs][j]),\n                        'CrafterMint: tokenId already minted'\n                    );\n\n                    //Update ingredient `tokenIds`, push additional ERC721 tokenId\n                    ingredient.tokenIds.push(_outputsERC721Ids[erc721Outputs][j]);\n                }\n                erc721Outputs += 1;\n            }\n        }\n    }\n\n    /**\n     * @dev removes outputs from the contract balances. If to != address(0),\n     * then assets are also minted to that address\n     * @param amount sets of outputs to remove\n     * @param to address to send outputs to, if applicable\n     */\n    function _removeOutputs(uint96 amount, address to) internal override {\n        require(amount > 0, 'CrafterMint: amount cannot be 0!');\n        require(amount <= craftableAmount, 'CrafterMint: Not enough resources to craft!');\n\n        craftableAmount -= amount;\n\n        for (uint256 i = 0; i < outputs.length; i++) {\n            PluginsCore.Ingredient storage ingredient = outputs[i];\n            if (ingredient.token == PluginsCore.TokenType.erc20 && to != address(0))\n                ERC20Owl(ingredient.contractAddr).mint(_msgSender(), ingredient.amounts[0] * amount);\n            else if (ingredient.token == PluginsCore.TokenType.erc721) {\n                for (uint256 j = 0; j < amount; j++) {\n                    if (to != address(0))\n                        ERC721Owl(ingredient.contractAddr).mint(\n                            _msgSender(),\n                            ingredient.tokenIds[ingredient.tokenIds.length - 1]\n                        );\n\n                    // Pop `tokenId`s from the back\n                    ingredient.tokenIds.pop();\n                }\n            } else if (ingredient.token == PluginsCore.TokenType.erc1155 && to != address(0)) {\n                uint256[] memory amounts = new uint256[](ingredient.amounts.length);\n                for (uint256 j = 0; j < ingredient.amounts.length; j++) {\n                    amounts[j] = ingredient.amounts[j] * amount;\n                }\n\n                ERC1155Owl(ingredient.contractAddr).mintBatch(_msgSender(), ingredient.tokenIds, amounts, new bytes(0));\n            }\n        }\n    }\n\n    /**********************\n            ERC165\n    **********************/\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/plugins/Transformer/TransformerCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../PluginsCore.sol';\n\n/**\n * @dev abstract contract that contains all the utilities and types required for\n * Transformer contract\n */\nabstract contract TransformerCore is PluginsCore {\n    enum GeneTransformType {\n        none,\n        add,\n        sub,\n        mult,\n        set\n    }\n\n    // Defines specification of how a specific gene is transformed\n    struct GeneMod {\n        GeneTransformType geneTransformType;\n        uint256 value;\n    }\n\n    /**********************\n           Utilities\n    **********************/\n\n    /**\n     * @dev Uses bitmask to transform inputted DNA according to modifications\n     * @param currDna original DNA, represented in base 10\n     * @param genes array representing start indexes of genes within binary\n     * representation of currDna\n     * @param modifications array describing modifications to each gene\n     * @return newDna the transformed DNA\n     */\n    function transform(\n        uint256 currDna,\n        uint8[] memory genes,\n        GeneMod[] memory modifications\n    ) internal pure returns (uint256 newDna) {\n        for (uint16 geneIdx = 0; geneIdx < genes.length; geneIdx++) {\n            // Genes array gives index ranges on the binary format of currDna\n            uint16 geneStartIdx = genes[geneIdx];\n            // If on last element of genes, set end to 256\n            uint16 geneEndIdx = geneIdx < genes.length - 1 ? genes[geneIdx + 1] : 256;\n\n            uint256 bitmask = get256Bitmask(geneStartIdx, geneEndIdx);\n\n            // Once the bitmask extracts the gene that needs to be operated on\n            // in the iteration, the binary data needs to be shifted all the way\n            // to the right so that operations are done on the gene as if it was\n            // its own individual number. If we have dna '01 10 01' and we're\n            // working on the '10'. Adding one needs to yield '11', not '10 01'.\n            // So after bitmask, '10 00' was shifted to '00 10' so operations\n            // are done correctly\n            uint256 gene = (currDna & bitmask) >> geneStartIdx;\n\n            uint256 maxBits = geneEndIdx - geneStartIdx;\n\n            // Execution of modifications\n            GeneMod memory currMod = modifications[geneIdx];\n            if (currMod.geneTransformType == GeneTransformType.add) {\n                uint256 sum = gene + currMod.value;\n\n                // Handle overflow with ceiling\n                if (sum > 2**maxBits - 1) gene = 2**maxBits - 1;\n                else gene = sum;\n            } else if (currMod.geneTransformType == GeneTransformType.sub) {\n                // Handle underflow with floor\n                if (currMod.value > gene) gene = 0;\n                else gene = gene - currMod.value;\n            } else if (currMod.geneTransformType == GeneTransformType.mult) {\n                uint256 prod = gene * currMod.value;\n                if (prod > 2**maxBits - 1) gene = 2**maxBits - 1;\n                else gene = prod;\n            } else if (currMod.geneTransformType == GeneTransformType.set) {\n                // Set must be in range, otherwise ignored\n                if (currMod.value <= 2**maxBits - 1 && currMod.value >= 0) gene = currMod.value;\n            }\n\n            // Shift back to original representation\n            gene = gene << geneStartIdx;\n\n            newDna = newDna | gene;\n        }\n    }\n\n    /**\n     * @dev Generates a 256-bit bitmask from startBit:endBit\n     * @param startBit beginning of mask\n     * @param endBit end of mask\n     * @return bitMask combined bitmask\n     */\n    function get256Bitmask(uint16 startBit, uint16 endBit) internal pure returns (uint256 bitMask) {\n        uint256 bitMaskStart = type(uint256).max << startBit;\n        uint256 bitMaskEnd = type(uint256).max >> (256 - endBit);\n        bitMask = bitMaskStart & bitMaskEnd;\n    }\n}\n"
    },
    "contracts/plugins/Transformer/Transformer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../../assets/ERC721/ERC721OwlAttributes.sol';\nimport './TransformerCore.sol';\n\n/**\n * @dev Contract module that enables \"transformation\" of {ERC721OwlAttributes}\n * tokens. The assumption with {ERC721OwlAttributes} is that the attributes of\n * one individual token are encoded into a number, called \"dna\". This number is\n * then mapped to the `tokenId`. Transforming configuration is set by one\n * {Ingredient}[] (the inputs) and a {GeneMod}[] (the modifications). The inputs\n * are the cost for the modifications to go through (as set by the contract\n * deployer).\n *\n * ```\n * enum GeneTransformType {\n *     none,\n *     add,\n *     sub,\n *     mult,\n *     set\n * }\n *\n * struct GeneMod {\n *     GeneTransformType geneTransformType;\n *     uint256 value;\n * }\n *\n * struct Ingredient {\n *     TokenType token;\n *     ConsumableType consumableType;\n *     address contractAddr;\n *     uint256[] amounts;\n *     uint256[] tokenIds;\n * }\n * ```\n *\n * Once the {Ingredient}s in the `inputs` array have been used/consumed, the\n * contract will update the \"dna\" associated with the `tokenId` submitted by the\n * user. See {ERC721OwlAttributes} for an in-depth explanation of how \"dna\"\n * encodes `tokenId` attributes.\n */\ncontract Transformer is TransformerCore, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://Transformer/', version)));\n\n    /**********************\n             Events\n    **********************/\n    event Transform(address indexed nftAddr, uint256 indexed tokenId, uint256 oldDna, uint256 newDna);\n\n    /**********************\n             Storage\n    **********************/\n\n    address public burnAddress;\n    Ingredient[] private inputs;\n    address nftAddr;\n\n    uint8[] genes;\n    GeneMod[] modifications;\n\n    /**********************\n        Initialization\n    **********************/\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner, no special permissions as of current release\n     * @param _burnAddress Burn address for burn inputs\n     * @param _inputs input ingredients for configuration\n     * @param _genes array denoting start location of genes within the 256 bit\n     * DNA\n     * @param _modifications array denoting the modifications to be made upon\n     * each gene after transformation\n     * @param _nftAddr the address of the ERC721Owl contract\n     * @param _forwarder trusted forwarder address for open GSN\n     */\n    function initialize(\n        address _admin,\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        uint8[] memory _genes,\n        GeneMod[] memory _modifications,\n        address _nftAddr,\n        address _forwarder\n    ) external initializer {\n        __Transformer_init(_admin, _burnAddress, _inputs, _genes, _modifications, _nftAddr, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        uint8[] memory _genes,\n        GeneMod[] memory _modifications,\n        address _nftAddr,\n        address _forwarder\n    ) external onlyInitializing {\n        __Transformer_init(_admin, _burnAddress, _inputs, _genes, _modifications, _nftAddr, _forwarder);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` are valid and\n     * creates the configuration\n     */\n    function __Transformer_init(\n        address _admin,\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        uint8[] memory _genes,\n        GeneMod[] memory _modifications,\n        address _nftAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        require(_burnAddress != address(0), 'Transformer: burn address must not be 0');\n        require(_inputs.length > 0, 'Transformer: A crafting input must be given!');\n        __OwlBase_init(_admin, _forwarder);\n\n        __Transformer_init_unchained(_burnAddress, _inputs, _genes, _modifications, _nftAddr);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and are valid and\n     * creates the configuration\n     */\n    function __Transformer_init_unchained(\n        address _burnAddress,\n        Ingredient[] calldata _inputs,\n        uint8[] memory _genes,\n        GeneMod[] memory _modifications,\n        address _nftAddr\n    ) internal onlyInitializing {\n        _validateInputs(_inputs, inputs);\n\n        require(\n            _genes.length == _modifications.length,\n            'Transformer: length of genes must be the same as length of modifications'\n        );\n\n        for (uint256 i = 0; i < _modifications.length; i++) {\n            modifications.push(_modifications[i]); // deep copy\n        }\n\n        burnAddress = _burnAddress;\n        genes = _genes;\n        nftAddr = _nftAddr;\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @dev Used to transform. Consumes inputs and modifies DNA of inputted NFT\n     * token.\n     * @notice the transformer instance from which this method is called from\n     * must have ERC721OwlAttributes DNA_ROLE\n     * @param tokenId ID of NFT token to transform\n     * @param _inputERC721Ids Array of pre-approved NFTs for crafting usage.\n     */\n    function transform(uint256 tokenId, uint256[][] calldata _inputERC721Ids) external {\n        require(\n            IERC721Upgradeable(nftAddr).ownerOf(tokenId) == _msgSender(),\n            'Transformer: you are not the owner of that ID!'\n        );\n\n        _useInputs(inputs, _msgSender(), burnAddress, _inputERC721Ids, 1);\n\n        // Transform DNA\n        uint256 currDna = ERC721OwlAttributes(nftAddr).getDna(tokenId);\n        uint256 newDna = transform(currDna, genes, modifications);\n\n        // This contract must have DNA_ROLE\n        ERC721OwlAttributes(nftAddr).updateDna(tokenId, newDna);\n        emit Transform(nftAddr, tokenId, currDna, newDna);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/assets/ERC721/ERC721OwlAttributes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport './ERC721Owl.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol';\n\n/**\n * @dev This implementation is an extension of OwlProtocol's base {ERC721Owl}\n * that enables on-chain encoding. In most uses of `ERC721`, contract deployers\n * have chosen to keep all metadata off-chain. While this is\n * economical in terms of gas costs it also disallows on-chain actors\n * (first-party or third-party) to deploy contracts that depend on the metadata.\n * This contract solves the latter without sacrificing on the former.\n *\n * In this contract, each `tokenId` is auto-incremented, solely determined by\n * the order of the mint. Each `tokenId` is also paired with a `dna` at the time\n * of mint. The `dna` will hold an encoding of all attributes for that\n * specific `tokenId`, stored in the `dnas` mapping.\n *\n * A \"dna\" will be stored in its decimal form, however all the metadata can\n * be decoded from its binary form, given the configuration of its \"genes\". A\n * \"gene\" represents a potential attribute that a `tokenId` can posses. The\n * size of the \"gene\" (how many bits it will be allocated in the binary form)\n * will be determined by the amount of possible options the attribute (that the\n * \"gene\" represents) can have.\n *\n * A quick exemplification of the concept of \"genes\": Suppose an\n * {ERC721OwlAttributes} instance with 3 attributes and 4 options for each\n * attribute: 4 options can be encoded into two bits (log(4) = 2). Since there\n * are three total attributes, the `tokenId`s in this {ERC721OwlAttributes}\n * instance will require 6 bits for encoding. Suppose the attributes options are\n * in arrays:\n *\n * ```\n * attributes1 = [option1, ..., option4]\n * attributes2 = [option1, ..., option4]\n * attributes3 = [option1, ..., option4]\n * ```\n *\n * So if a `tokenId` was minted with a \"dna\" that had a binary format of\n * `01 10 11`, that `tokenId`'s metadata would be:\n * - `option2` for `attributes1`\n * - `option3` for `attributes2`\n * - `option4` for `attributes3`\n *\n * `01 10 11` in its decimal form is 27 which is what would be mapped to the\n * `tokenId` it was assigned during minting.\n *\n * If it were ever required, the genes array for this {ERC721OwlAttribtues}\n * instance would be `[0, 2, 4, 6]`. They are, in order, the index ranges of\n * each \"gene\" in the binary format of the \"dna\". The genes array must begin at\n * 0 and be strictly increasing. The max size of a \"dna\" is 256 bits so no\n * element in the genes should be above 255 (it is a uint8[] array).\n *\n * The `dnas` mapping can be dynamically updated by `DNA_ROLE` through the\n * `updateDna()` function.\n */\ncontract ERC721OwlAttributes is ERC721Owl {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using StringsUpgradeable for uint256;\n\n    bytes32 private constant DNA_ROLE = keccak256('DNA_ROLE');\n    bytes4 private constant ERC165TAG =\n        bytes4(keccak256(abi.encodePacked('OWLProtocol://ERC721OwlAttributes/', VERSION)));\n\n    /**********************\n           Storage\n    **********************/\n\n    // Mapping from tokenId to dna\n    mapping(uint256 => uint256) private dnas;\n\n    // Auto-incrementing tokenIds\n    CountersUpgradeable.Counter private nextId;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner\n     * @param _name name\n     * @param _symbol symbol\n     * @param baseURI_ uri\n     * @param _forwarder trusted forwarder address for openGSN\n     */\n    function initialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external virtual override initializer {\n        __ERC721OwlAttributes_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external virtual override onlyInitializing {\n        __ERC721OwlAttributes_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    function __ERC721OwlAttributes_init(\n        address _admin,\n        string memory _name,\n        string memory _symbol,\n        string memory baseURI_,\n        address _forwarder\n    ) internal onlyInitializing {\n        __ERC721Owl_init(_admin, _name, _symbol, baseURI_, _forwarder);\n        _grantRole(DNA_ROLE, _admin);\n\n        __ERC721OwlAttributes_init_unchained();\n    }\n\n    function __ERC721OwlAttributes_init_unchained() internal onlyInitializing {}\n\n    /**********************\n          Interaction\n    **********************/\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants DNA_ROLE to `to`\n     * @param to address to\n     */\n    function grantDna(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(DNA_ROLE, to);\n    }\n\n    /**\n     * @dev returns uri for token metadata.\n     * @param tokenId tokenId metadata to fetch\n     * @return uri at which metadata is housed\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory uri) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n        string memory baseURI = _baseURI();\n        // Uri is not based of tokenId but rather by the dna that is indexed by\n        // the tokenId\n        uri = bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, dnas[tokenId].toString())) : '';\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows MINTER_ROLE to mint NFTs\n     * @param to address to\n     * @param dna of next tokenId\n     */\n    function mint(address to, uint256 dna) public virtual override onlyRole(MINTER_ROLE) {\n        dnas[nextId.current()] = dna;\n        _mint(to, nextId.current());\n        nextId.increment();\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows caller to mint NFTs (safeMint)\n     * @param to address to\n     * @param dna of next tokenId\n     */\n    function safeMint(address to, uint256 dna) public virtual override onlyRole(MINTER_ROLE) {\n        dnas[nextId.current()] = dna;\n        _safeMint(to, nextId.current());\n        nextId.increment();\n    }\n\n    /**\n     * @notice Must have DNA_ROLE\n     * @dev Allows changing the dna of a tokenId\n     * @param tokenId whose dna to change\n     * @param dna new dna for the provided tokenId\n     */\n    function updateDna(uint256 tokenId, uint256 dna) external onlyRole(DNA_ROLE) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n        dnas[tokenId] = dna;\n    }\n\n    /**\n     * @dev Getter for dna of tokenId\n     * @param tokenId whose dna to change\n     * @return dna of tokenId\n     */\n    function getDna(uint256 tokenId) external view returns (uint256) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n        return dnas[tokenId];\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Owl) returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/plugins/Minter/builds/MinterBreeding.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nimport '../../../assets/ERC721/ERC721Owl.sol';\nimport '../MinterCore.sol';\nimport '../../../utils/SourceRandom.sol';\nimport '../../../utils/RosalindDNA.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ncontract MinterBreeding is MinterCore {\n    uint8 public constant defaultGenesNum = 8;\n    uint8 public constant defaultRequiredParents = 2;\n    uint256 public constant defaultBreedingCooldownSeconds = 604800; // 7 days\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://MinterBreeding/', version)));\n\n    // Store breeding details\n    struct BreedingRules {\n        uint8 requiredParents;\n        uint16 generationCooldownMultiplier;\n        uint8[] genes;\n        uint256 breedCooldownSeconds;\n        uint256[] mutationRates;\n    }\n\n    mapping(uint256 => uint256) lastBredTime;\n    BreedingRules private _breedingRules;\n\n    event SetBreedingRules(uint8 requiredParents, uint256 breedCooldownSeconds, uint8[] genes, uint256[] mutationRates);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // Constructor\n    function initialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        BreedingRules calldata breedingRules_,\n        address _forwarder\n    ) external initializer {\n        __MinterBreeding_init(\n            _admin,\n            _mintFeeToken,\n            _mintFeeAddress,\n            _mintFeeAmount,\n            _nftContractAddr,\n            breedingRules_,\n            _forwarder\n        );\n    }\n\n    function proxyIntiialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        BreedingRules calldata breedingRules_,\n        address _forwarder\n    ) external onlyInitializing {\n        __MinterBreeding_init(\n            _admin,\n            _mintFeeToken,\n            _mintFeeAddress,\n            _mintFeeAmount,\n            _nftContractAddr,\n            breedingRules_,\n            _forwarder\n        );\n    }\n\n    function __MinterBreeding_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        BreedingRules calldata breedingRules_,\n        address _forwarder\n    ) internal onlyInitializing {\n        __MinterCore_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n        __MinterBreeding_init_unchained(breedingRules_);\n    }\n\n    function __MinterBreeding_init_unchained(BreedingRules calldata breedingRules_) internal onlyInitializing {\n        _breedingRules = breedingRules_;\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function breed(uint256[] calldata parents) public returns (uint256 dna) {\n        // Breed species\n        dna = _breedSpecies(parents, msg.sender);\n\n        // Mint Operation\n        MinterCore._mintForFee(msg.sender, dna);\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function safeBreed(uint256[] calldata parents) public returns (uint256 dna) {\n        // Breed species\n        dna = _breedSpecies(parents, msg.sender);\n\n        // Mint Operation\n        MinterCore._safeMintForFee(msg.sender, dna);\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function setBreedingRules(\n        uint8 requiredParents,\n        uint16 generationCooldownMultiplier,\n        uint256 breedCooldownSeconds,\n        uint8[] memory genes,\n        uint256[] memory mutationRates\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Breed species\n        BreedingRules storage r = _breedingRules;\n\n        // Set values\n        r.requiredParents = requiredParents;\n        r.generationCooldownMultiplier = generationCooldownMultiplier;\n        if (generationCooldownMultiplier != 0)\n            require(genes[0] == 0 && genes[1] == 8, 'Generations requires gene[0]=8');\n        r.breedCooldownSeconds = breedCooldownSeconds;\n\n        // Delete arrays in case they exist\n        if (r.genes.length > 0) delete r.genes;\n        if (r.mutationRates.length > 0) delete r.mutationRates;\n\n        // Set array vals\n        for (uint256 i = 0; i < genes.length; i++) r.genes.push(genes[i]);\n        for (uint256 i = 0; i < mutationRates.length; i++) r.mutationRates.push(mutationRates[i]);\n\n        emit SetBreedingRules(requiredParents, breedCooldownSeconds, genes, mutationRates);\n    }\n\n    /**\n     * @dev Returns the current breeding rules used for a species\n     */\n    function getBreedingRules()\n        public\n        view\n        returns (\n            uint8 requiredParents,\n            uint256 breedCooldownSeconds,\n            uint8[] memory genes,\n            uint256[] memory mutationRates\n        )\n    {\n        (requiredParents, breedCooldownSeconds, genes, mutationRates) = _getBreedingRules();\n    }\n\n    /**\n     * @dev Internal function to do the heavy lifting for breeding\n     * @param parents parents to use for breeding\n     * @param caller owner of parent NFTs (this will be verified)\n     */\n    function _breedSpecies(uint256[] calldata parents, address caller) internal returns (uint256 dna) {\n        // Fetch breeding rules\n        uint8 requiredParents;\n        uint8[] memory genes;\n        uint256[] memory mutationRates;\n        uint256 breedCooldownSeconds;\n        uint16 generationCooldownMultiplier = _breedingRules.generationCooldownMultiplier;\n        (requiredParents, breedCooldownSeconds, genes, mutationRates) = _getBreedingRules();\n\n        // Make sure we're following rules\n\n        require(parents.length == requiredParents, 'Invalid number of parents!');\n        ERC721Owl nft = ERC721Owl(nftContractAddr);\n        for (uint256 i = 0; i < parents.length; i++) {\n            uint8 parentGeneration = RosalindDNA.getGenCount(parents[i]);\n            // Require not on cooldown\n            require(\n                breedCooldownSeconds + parentGeneration * generationCooldownMultiplier <\n                    block.timestamp - lastBredTime[parents[i]],\n                'NFT currently on cooldown!'\n            );\n            // By updating the timestamp right after each check,\n            // we prevent the same parent from being entered twice.\n            lastBredTime[parents[i]] = block.timestamp;\n\n            // Require ownership of NFTs\n            require(caller == nft.ownerOf(parents[i]), 'You must own all parents!');\n        }\n\n        // Get Parent DNA\n        uint256[] memory parentsDNA = new uint256[](parents.length);\n        for (uint256 i = 0; i < parents.length; i++)\n            parentsDNA[i] = IERC721OwlAttributes(nftContractAddr).getDna(parents[i]);\n\n        // Generate random seed and breed\n        uint256 randomSeed = SourceRandom.getRandomDebug();\n        if (mutationRates.length == 0) dna = RosalindDNA.breedDNASimple(parentsDNA, genes, randomSeed);\n        else dna = RosalindDNA.breedDNAWithMutations(parentsDNA, genes, randomSeed, mutationRates);\n\n        // Generation Counting\n        if (generationCooldownMultiplier != 0) dna = RosalindDNA.setGenCount(dna, parentsDNA);\n\n        return dna;\n    }\n\n    /**\n     * @dev Internal function to do the heavy lifting for breeding\n     * @return requiredParents number of parents required (defaults to 2)\n     * @return breedCooldownSeconds number of seconds to cooldown (defaults to 7 days)\n     * @return genes 256-bit gene split locations (defaults to 8 32-bit genes)\n     * @return mutationRates mutation rate locations (defaults to none)\n     */\n    function _getBreedingRules()\n        internal\n        view\n        returns (\n            uint8 requiredParents,\n            uint256 breedCooldownSeconds,\n            uint8[] memory genes,\n            uint256[] memory mutationRates\n        )\n    {\n        BreedingRules storage rules = _breedingRules;\n\n        // Require parents (2 by default)\n        requiredParents = rules.requiredParents;\n        if (requiredParents == 0) requiredParents = defaultRequiredParents;\n\n        // Cooldown (7 days by default)\n        breedCooldownSeconds = rules.breedCooldownSeconds;\n        if (breedCooldownSeconds == 0) breedCooldownSeconds = defaultBreedingCooldownSeconds;\n\n        // Genes (8 equal strands by default)\n        uint8 genesNum = uint8(rules.genes.length);\n        if (genesNum == 0) genesNum = 8;\n        genes = new uint8[](genesNum);\n\n        if (rules.genes.length == 0)\n            // Calculate gene splits (i.e. [0, 32, 64...])\n            for (uint256 i = 0; i < defaultGenesNum; i++) genes[i] = uint8(i * (256 / defaultGenesNum));\n        // Pickup gene splits (from storage configuration)\n        else for (uint256 i = 0; i < genesNum; i++) genes[i] = rules.genes[i];\n\n        // Grab mutation rates (none by default)\n        mutationRates = new uint256[](rules.mutationRates.length);\n        if (mutationRates.length != 0) {\n            require(mutationRates.length == genes.length, 'mutation rates length and genes length must match.');\n            // Copy over mutation data\n            for (uint256 i = 0; i < mutationRates.length; i++) mutationRates[i] = rules.mutationRates[i];\n        }\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n\ninterface IMinterBreeding is IERC165Upgradeable {\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function breed(uint256[] calldata parents) external returns (uint256 tokenId);\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     * @return tokenId minted token id\n     */\n    function safeBreed(uint256[] calldata parents) external returns (uint256 tokenId);\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     * @return tokenId minted token id\n     */\n    function setBreedingRules(\n        uint8 requiredParents,\n        uint256 breedCooldownSeconds,\n        uint8[] memory genes,\n        uint256[] memory mutationRates\n    ) external returns (uint256 tokenId);\n\n    /**\n     * @dev Returns the current breeding rules used for a species\n     */\n    function getBreedingRules()\n        external\n        view\n        returns (\n            uint8 requiredParents,\n            uint256 breedCooldownSeconds,\n            uint8[] memory genes,\n            uint256[] memory mutationRates\n        );\n}\n\ninterface IERC721OwlAttributes {\n    /**\n     * @dev Getter for dna of tokenId\n     * @param tokenId whose dna to change\n     * @return dna of tokenId\n     */\n    function getDna(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@opengsn/contracts/src/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-inline-assembly\npragma solidity >=0.6.9;\n\nimport \"./interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address private _trustedForwarder;\n\n    function trustedForwarder() public virtual view returns (address){\n        return _trustedForwarder;\n    }\n\n    function _setTrustedForwarder(address _forwarder) internal {\n        _trustedForwarder = _forwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public virtual override view returns(bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            ret = msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\n     * should be used in the contract instead of msg.data, where this difference matters.\n     */\n    function _msgData() internal override virtual view returns (bytes calldata ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            return msg.data[0:msg.data.length-20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/plugins/Minter/MinterCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n// import './modules/MintGuard/IMintGuard.sol';\nimport '../../assets/ERC721/ERC721Owl.sol';\nimport '../../utils/ERC1820/ERC1820ImplementerAuthorizeAll.sol';\nimport '../../OwlBase.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\nabstract contract MinterCore is OwlBase {\n    address public mintFeeToken;\n    address public mintFeeAddress;\n    uint256 public mintFeeAmount;\n    address public nftContractAddr;\n\n    function __MinterCore_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_admin, _forwarder);\n        __MinterCore_init_unchained(_mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr);\n    }\n\n    function __MinterCore_init_unchained(\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr\n    ) internal onlyInitializing {\n        mintFeeToken = _mintFeeToken;\n        mintFeeAddress = _mintFeeAddress;\n        mintFeeAmount = _mintFeeAmount;\n        nftContractAddr = _nftContractAddr;\n    }\n\n    /**\n     * @dev Base minting function (not safeMint). Called\n     * by implementation contracts.\n     * @param buyer who's paying the ERC20 fee / gets the ERC721 token\n     * @param tokenId the token identifier to mint\n     */\n    function _mintForFee(address buyer, uint256 tokenId) internal {\n        // Transfer ERC20\n        if (mintFeeAmount != 0)\n            SafeERC20Upgradeable.safeTransferFrom(\n                IERC20Upgradeable(mintFeeToken),\n                buyer,\n                mintFeeAddress,\n                mintFeeAmount\n            );\n\n        // Call minting operation\n        ERC721Owl(nftContractAddr).mint(buyer, tokenId);\n    }\n\n    /**\n     * @dev Base minting function (safeMint). Called\n     * by implementation contracts.\n     * @param buyer who's paying the ERC20 fee / gets the ERC721 token\n     * @param tokenId the token identifier to mint\n     */\n    function _safeMintForFee(address buyer, uint256 tokenId) internal {\n        // Transfer ERC20\n        if (mintFeeAmount != 0)\n            SafeERC20Upgradeable.safeTransferFrom(\n                IERC20Upgradeable(mintFeeToken),\n                buyer,\n                mintFeeAddress,\n                mintFeeAmount\n            );\n\n        // Call minting operation\n        ERC721Owl(nftContractAddr).safeMint(buyer, tokenId);\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/utils/SourceRandom.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Sources different levels of randomness\n *\n */\nlibrary SourceRandom {\n    /**\n     * @notice Not truly random. Use for debugging only\n     * @dev Returns a random uint256 sourced from the current time\n     * @return uint256 random value\n     */\n    function getRandomDebug() internal view returns (uint256) {\n        uint256 random = uint256(keccak256(abi.encode(block.timestamp)));\n        return random;\n    }\n\n    /**\n     * @dev Returns a random uint256 sourced from a seed\n     * @return uint256 random value\n     */\n    function getSeededRandom(uint256 seed, uint256 nonce) internal pure returns (uint256) {\n        uint256 random = uint256(keccak256(abi.encode(seed, nonce)));\n        return random;\n    }\n}\n"
    },
    "contracts/utils/RosalindDNA.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './SourceRandom.sol';\n\n/**\n * @dev Library used for combining uint256-encoded genes\n * Named Rosalind after chemist\n * Rosalind Franklin who discovered double-helix and significantly\n * furthered our understanding of DNAs molecular structure.\n */\nlibrary RosalindDNA {\n    // First 8 bits are generation\n    uint256 private constant GENERATION_MASK = 0x00000000000000FF;\n\n    /**\n     * @dev Breeds multiple parents DNA, returning a new combined\n     * @param parentsDNA N different parent DNAs\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     * @return childDNA combined child DNA\n     */\n    function breedDNASimple(\n        uint256[] memory parentsDNA,\n        uint8[] memory genes,\n        uint256 randomSeed\n    ) internal pure returns (uint256 childDNA) {\n        // Loop genes\n        for (uint16 geneIdx = 0; geneIdx < genes.length; geneIdx++) {\n            // Gene details\n            uint16 geneStartIdx = genes[geneIdx];\n            uint16 geneEndIdx = geneIdx < genes.length - 1 ? genes[geneIdx + 1] : 256;\n\n            // Select parent\n            uint8 randomParentIdx = uint8(SourceRandom.getSeededRandom(randomSeed, geneIdx) % parentsDNA.length);\n            uint256 selectedParent = parentsDNA[randomParentIdx];\n\n            // Isolate our gene\n            uint256 bitmask = get256Bitmask(geneStartIdx, geneEndIdx);\n            uint256 gene = selectedParent & bitmask;\n\n            // Save genes to childDNA\n            childDNA = childDNA | gene;\n        }\n\n        return childDNA;\n    }\n\n    /**\n     * @dev Breeds multiple parents DNA, returning a new combined DNA\n     * Allows for random mutations to occur, producing random bits instead.\n     * @param parentsDNA N different parent DNAs\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     * @param mutationRates probability that a random gene is picked vs. mutated.\n     * A higher mutation rate means a higher probability of having a random gene.\n     * The mutation rate m is a probability of m/(2^256-1) or in other words the\n     * probability that geneRandomnessSeed <= m. We therefore assign a mutated\n     * gene at the following rates according to m:\n     * 0 = 000... => 0%\n     * 2^254-1 = 001... => 25%\n     * 2^255-1 = 011... => 50%\n     * 2^255 + 2^254 -1 => 75%\n     * 2^256-1 = 111... => 100% Always mutate\n     * Calculated probability as a function: 1/2^(256-m)\n     * @return childDNA combined child DNA with mutations occuring.\n     */\n    function breedDNAWithMutations(\n        uint256[] memory parentsDNA,\n        uint8[] memory genes,\n        uint256 randomSeed,\n        uint256[] memory mutationRates\n    ) internal pure returns (uint256 childDNA) {\n        // Breed normally\n        childDNA = breedDNASimple(parentsDNA, genes, randomSeed);\n\n        // Add mutations\n        childDNA = generateMutations(childDNA, genes, randomSeed, mutationRates);\n    }\n\n    /**\n     * @dev Mutates encoded DNA\n     * @param dna existing DNA to mutate\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     * @param mutationRates probability that a random gene is picked vs. mutated.\n     * A higher mutation rate means a higher probability of having a random gene.\n     * The mutation rate m is a probability of m/(2^256-1) or in other words the\n     * probability that geneRandomnessSeed <= m. We therefore assign a mutated\n     * gene at the following rates according to m:\n     * 0 = 000... => 0%\n     * 2^254-1 = 001... => 25%\n     * 2^255-1 = 011... => 50%\n     * 2^255 + 2^254 -1 => 75%\n     * 2^256-1 = 111... => 100% Always mutate\n     * Calculated probability as a function: 1/2^(256-m)\n     * @return mutatedDNA combined child DNA with mutations occuring.\n     */\n    function generateMutations(\n        uint256 dna,\n        uint8[] memory genes,\n        uint256 randomSeed,\n        uint256[] memory mutationRates\n    ) internal pure returns (uint256 mutatedDNA) {\n        // Start with empty mask (no mutations)\n        uint256 mutationMask;\n\n        // Loop genes, create a mutation mask\n        // I.e. mutationMask = 11101011101011110000111\n        // Then once at the end: mutatedDNA = mutationMask & randomSeed\n        for (uint256 geneIdx = 0; geneIdx < genes.length; geneIdx++) {\n            // Decide if we want to mutate\n            uint256 geneMutationSeed = SourceRandom.getSeededRandom(randomSeed, geneIdx);\n            if (geneMutationSeed > mutationRates[geneIdx])\n                // Skip to the next gene if we shouldn't mutate\n                continue;\n\n            // Note our mutation in mutationMask\n            uint16 geneStartIdx = genes[geneIdx];\n            uint16 geneEndIdx = geneIdx < genes.length - 1 ? genes[geneIdx + 1] : 255;\n\n            uint256 bitmask = get256Bitmask(geneStartIdx, geneEndIdx);\n            mutationMask = mutationMask | bitmask;\n        }\n\n        // Source new mutations from our existing dna + random seed, then merge\n        uint256 mutations = SourceRandom.getSeededRandom(dna, randomSeed);\n        mutatedDNA = mutations & mutationMask;\n\n        // Merge existing DNA after slicing out mutation genes\n        dna = dna & (~mutationMask);\n        mutatedDNA = dna | mutatedDNA;\n    }\n\n    /**\n     * @dev Sets an offsprings generation (increases max parent +1)\n     * @param child child dna\n     * @param parentsDNA array of parent dna\n     */\n    function setGenCount(uint256 child, uint256[] memory parentsDNA) internal pure returns (uint256) {\n        // Discover oldest parent\n        uint256 oldestParent;\n        for (uint256 i = 0; i < parentsDNA.length; i++) {\n            uint256 parentAge = uint8(parentsDNA[i] & GENERATION_MASK);\n            if (parentAge > oldestParent) oldestParent = parentAge;\n        }\n\n        // 255 == oldest generation allowed\n        if (oldestParent == type(uint8).max) revert('Max generation reached!');\n\n        // Remove any age from child\n        child = child & ~GENERATION_MASK;\n        // Set new age\n        child = child | (oldestParent + 1);\n\n        return child;\n    }\n\n    /**\n     * @dev Gets the generation for a specimen\n     * @param child child dna to read specimen age\n     */\n    function getGenCount(uint256 child) internal pure returns (uint8) {\n        // Returns the age of generation\n        return uint8(child & GENERATION_MASK);\n    }\n\n    /**\n     * @dev Generates a 256-bit bitmask from startBit:endBit\n     * @param startBit beginning of mask\n     * @param endBit end of mask\n     * @return bitMask combined bitmask\n     */\n    function get256Bitmask(uint16 startBit, uint16 endBit) internal pure returns (uint256 bitMask) {\n        uint256 bitMaskStart = type(uint256).max << startBit;\n        uint256 bitMaskEnd = type(uint256).max >> (256 - endBit);\n        bitMask = bitMaskStart & bitMaskEnd;\n    }\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\n     * should be used in the contract instead of msg.data, where this difference matters.\n     */\n    function _msgData() internal virtual view returns (bytes calldata);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/utils/ERC1820/ERC1820ImplementerAuthorizeAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC1820Implementer} interface.\n *\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\n * declare their willingness to be implementers.\n *\n * Any accounts requesting to add this to the registry will be approved.\n *\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\n * registration to be complete.\n */\ncontract ERC1820ImplementerAuthorizeAll {\n    bytes32 private constant _ERC1820_ACCEPT_MAGIC = keccak256('ERC1820_ACCEPT_MAGIC');\n\n    mapping(bytes32 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function canImplementInterfaceForAddress(\n        bytes32 interfaceHash,\n        address /*account*/\n    ) public view virtual returns (bytes32) {\n        return _supportedInterfaces[interfaceHash] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n    }\n\n    /**\n     * @dev Declares the contract as willing to be an implementer of\n     * `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer} and\n     * {IERC1820Registry-interfaceHash}.\n     */\n    function _registerInterfaceForAddress(bytes32 interfaceHash) internal virtual {\n        _supportedInterfaces[interfaceHash] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/testing/RosalindTestLab.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../utils/RosalindDNA.sol';\n\n/**\n * @dev **INTERNAL TOOL**\n * Used to test RosalindDNA library.\n */\ncontract RosalindTestLab {\n    /**\n     * @dev Breeds multiple parents DNA, returning a new combined\n     * @param parents N different parent DNAs\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     */\n    function breedDNASimple(\n        uint256[] memory parents,\n        uint8[] memory genes,\n        uint256 randomSeed\n    ) public pure returns (uint256) {\n        return RosalindDNA.breedDNASimple(parents, genes, randomSeed);\n    }\n\n    /**\n     * @dev Breeds multiple parents DNA, returning a new combined DNA\n     * Allows for random mutations to occur, producing random bits instead.\n     * @param parents N different parent DNAs\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     * @param mutationRates probability that a random gene is picked vs. mutated.\n     * A higher mutation rate means a higher probability of having a random gene.\n     * The mutation rate m is a probability of m/(2^256-1) or in other words the\n     * probability that geneRandomnessSeed <= m. We therefore assign a mutated\n     * gene at the following rates according to m:\n     * 0 = 000... => 0%\n     * 2^254-1 = 001... => 25%\n     * 2^255-1 = 011... => 50%\n     * 2^255 + 2^254 -1 => 75%\n     * 2^256-1 = 111... => 100% Always mutate\n     * Calculated probability as a function: 1/2^(256-m)\n     * @return childDNA combined child DNA with mutations occuring.\n     */\n    function breedDNAWithMutations(\n        uint256[] memory parents,\n        uint8[] memory genes,\n        uint256 randomSeed,\n        uint256[] memory mutationRates\n    ) public pure returns (uint256 childDNA) {\n        return RosalindDNA.breedDNAWithMutations(parents, genes, randomSeed, mutationRates);\n    }\n\n    /**\n     * @dev Mutates encoded DNA\n     * @param dna existing DNA to mutate\n     * @param genes start indicies of each gene.\n     * First index should ALWAYS be 0. Using [0, 128] splits\n     * the DNA into two genes of equal length\n     * @param randomSeed random value to use for gene splicing\n     * @param mutationRates probability that a random gene is picked vs. mutated.\n     * A higher mutation rate means a higher probability of having a random gene.\n     * The mutation rate m is a probability of m/(2^256-1) or in other words the\n     * probability that geneRandomnessSeed <= m. We therefore assign a mutated\n     * gene at the following rates according to m:\n     * 0 = 000... => 0%\n     * 2^254-1 = 001... => 25%\n     * 2^255-1 = 011... => 50%\n     * 2^255 + 2^254 -1 => 75%\n     * 2^256-1 = 111... => 100% Always mutate\n     * Calculated probability as a function: 1/2^(256-m)\n     * @return mutatedDNA combined child DNA with mutations occuring.\n     */\n    function generateMutations(\n        uint256 dna,\n        uint8[] memory genes,\n        uint256 randomSeed,\n        uint256[] memory mutationRates\n    ) public pure returns (uint256 mutatedDNA) {\n        return RosalindDNA.generateMutations(dna, genes, randomSeed, mutationRates);\n    }\n\n    /**\n     * @dev Gets the generation for a specimen\n     * @param child child dna to read specimen age\n     */\n    function getGenCount(uint256 child) public pure returns (uint256) {\n        // Returns the age of generation\n        return RosalindDNA.getGenCount(child);\n    }\n\n    /**\n     * @dev Sets an offsprings generation (increases max parent +1)\n     * @param child child dna\n     * @param parents array of parent dna\n     */\n    function setGenCount(uint256 child, uint256[] memory parents) public pure returns (uint256) {\n        return RosalindDNA.setGenCount(child, parents);\n    }\n}\n"
    },
    "contracts/plugins/Router/RouteRandomizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\nimport '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';\n\nimport '../../random/VRFBeacon.sol';\nimport '../PluginsCore.sol';\nimport '../../utils/SourceRandom.sol';\nimport '../../utils/Probability.sol';\n\ncontract RouteRandomizer is PluginsCore, KeeperCompatibleInterface, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://RouteRandomizer/', version)));\n\n    /**********************\n             State\n    **********************/\n    struct RouteElement {\n        uint256 epochBlock;\n        bytes[] args;\n    }\n\n    address[] public contracts;\n    bytes[] public signatures;\n    uint256[] public probabilities;\n    address public vrfBeacon;\n    RouteElement[] elements;\n    uint256 public queueIndex;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Create RouteRandomizer instance\n     * @param _admin the admin/owner of the contract\n     * @param _contracts array of contract addresses to route to, each instance is defined with unique recipe\n     * @param _signatures bytes array representing function signatures for each contract\n     * @param _probabilities array of cumulative proababilities associated with using a contract from contracts\n     * @param _forwarder address for trusted forwarder for open GSN integration\n     */\n    function initialize(\n        address _admin,\n        address[] memory _contracts,\n        bytes[] memory _signatures,\n        uint8[] memory _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) external initializer {\n        __RouteRandomizer_init(_admin, _contracts, _signatures, _probabilities, _vrfBeacon, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address[] memory _contracts,\n        bytes[] memory _signatures,\n        uint8[] memory _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) external onlyInitializing {\n        __RouteRandomizer_init(_admin, _contracts, _signatures, _probabilities, _vrfBeacon, _forwarder);\n    }\n\n    function __RouteRandomizer_init(\n        address _admin,\n        address[] memory _contracts,\n        bytes[] memory _signatures,\n        uint8[] memory _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) internal onlyInitializing {\n        require(_contracts.length == _signatures.length, '_contracts.length != _signatures.length');\n        __OwlBase_init(_admin, _forwarder);\n\n        __RouteRandomizer_init_unchained(_contracts, _signatures, _probabilities, _vrfBeacon);\n    }\n\n    function __RouteRandomizer_init_unchained(\n        address[] memory _contracts,\n        bytes[] memory _signatures,\n        uint8[] memory _probabilities,\n        address _vrfBeacon\n    ) internal onlyInitializing {\n        contracts = _contracts;\n        signatures = _signatures;\n        probabilities = _probabilities;\n        vrfBeacon = _vrfBeacon;\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    function requestRouteRandomize(bytes[] memory argsArr) external returns (uint256 requestId, uint256 blockNumber) {\n        (requestId, blockNumber) = VRFBeacon(vrfBeacon).requestRandomness();\n\n        elements.push(RouteElement(blockNumber, argsArr));\n    }\n\n    function checkUpkeep(\n        bytes memory /* checkData */\n    ) external view override returns (bool upkeepNeeded, bytes memory performData) {\n        assert(queueIndex <= elements.length);\n        if (elements.length == queueIndex) return (false, '0x');\n\n        uint256 randomness = VRFBeacon(vrfBeacon).getRandomness(elements[queueIndex].epochBlock);\n\n        if (randomness != 0) return (true, abi.encode(randomness, queueIndex));\n        return (false, '0x');\n    }\n\n    function performUpkeep(bytes memory performData) external override {\n        (uint256 randomness, uint256 queueIndexRequest) = abi.decode(performData, (uint256, uint256));\n\n        //make sure that checkUpKeep hasn't run twice on the same queueIndex\n        require(queueIndexRequest == queueIndex, 'Lootbox: queueIndex already processed');\n        _routeRandomize(elements[queueIndex].args, randomness);\n        queueIndex++;\n    }\n\n    function _routeRandomize(bytes[] memory argsArr, uint256 randomSeed) internal {\n        //randomly choose the crafter transfer contract to call\n        uint256 randomNumber = SourceRandom.getSeededRandom(randomSeed, queueIndex);\n        uint256 selectedContract = Probability.probabilityDistribution(randomNumber, probabilities);\n\n        address routedContract = contracts[selectedContract];\n\n        // uint256 sz = (argsArr[selectedContract].length);\n\n        // bytes memory a;\n        // assembly {\n        //     let fptr := mload(0x40)\n        //     let ptr := add(fptr, 0x20)\n        //     mstore(ptr, sload(add(signatures.slot, selectedContract)))\n        //     // prettier-ignore\n        //     for { let i := 0 } lt(i, sz) { i := add(i, 0x20) } {\n        //         mstore(add(ptr, add(i, 0x04)), mload(add(sub(fptr, sz), i)))\n        //     }\n        //     mstore(add(ptr, add(sz, 0x04)), shl(0x60, caller()))\n        //     mstore(fptr, add(sz, 0x20))\n        //     mstore(0x40, add(add(sz, 0x40), mload(0x40)))\n        //     a := fptr\n        // }\n\n        // console.logBytes(a);\n\n        bytes memory finalBytes = abi.encodePacked(\n            signatures[selectedContract],\n            argsArr[selectedContract],\n            _msgSender()\n        );\n\n        (bool success, bytes memory returnData) = routedContract.call(finalBytes);\n\n        if (!success) emit RouterError(queueIndex, _msgSender(), returnData);\n    }\n\n    // used for testing\n    function getRandomContract(uint256 queueIndex, uint256 randomSeed)\n        external\n        view\n        returns (uint256 selectedContract)\n    {\n        uint256 randomNumber = SourceRandom.getSeededRandom(randomSeed, queueIndex);\n        selectedContract = Probability.probabilityDistribution(randomNumber, probabilities);\n    }\n\n    function getQueueIndex() public view returns (uint256) {\n        return queueIndex;\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155ReceiverUpgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./KeeperBase.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
    },
    "contracts/random/VRFBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol';\nimport '@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol';\n// import '@openzeppelin/';\n\nimport './RandomBeacon.sol';\n\n/**\n * @dev A contract that acts as a central beacon for fetching random numbers\n * from Chainlink VRF. Multiple requests within an `EPOCH_PERIOD` (as defined by\n * VRFBeacon deployer) will be coupled into one request to `VRFCoordiantorV2`.\n * An `EPOCH_PERIOD` is simply a block range.\n *\n * Consumers of `VRFBeacon` will use the one random number as a seed to generate\n * another random number for the contract's own use case.\n */\ncontract VRFBeacon is VRFConsumerBaseV2, RandomBeacon {\n    /**********************\n             Events\n    **********************/\n\n    event Fulfilled(uint256 indexed requestId, uint256 indexed randomNumber);\n    event Requested(uint256 indexed requestId);\n\n    /**********************\n             Storage\n    **********************/\n\n    VRFCoordinatorV2Interface COORDINATOR;\n    bytes32 internal keyHash;\n\n    uint64 s_subscriptionId;\n    uint32 callbackGasLimit;\n    uint32 numWords = 1;\n\n    // Mapping from blockNumber to requestId\n    mapping(uint256 => uint256) public blockNumberToRequestId;\n\n    // Mapping from requestId to random number (0 if not fulfilled yet)\n    mapping(uint256 => uint256) public requestIdToRandomness;\n\n    /**\n     * @dev Constructor inherits VRFConsumerBase\n     */\n    constructor(\n        uint64 _subscriptionId,\n        address _vrf,\n        bytes32 _keyHash,\n        uint32 _callbackGasLimit,\n        uint8 _epochPeriod\n    ) VRFConsumerBaseV2(_vrf) RandomBeacon(_epochPeriod) {\n        require(_epochPeriod < 100 && _epochPeriod > 3, 'VRFBeacon: invalid number for _epoch period');\n\n        s_subscriptionId = _subscriptionId;\n        COORDINATOR = VRFCoordinatorV2Interface(_vrf);\n        keyHash = _keyHash;\n        callbackGasLimit = _callbackGasLimit;\n        EPOCH_PERIOD = _epochPeriod;\n    }\n\n    /**\n     * @param blockNumber in which request was made\n     * @return requestId of the EPOCH_PERIOD that `blockNumber` is in\n     */\n    function getRequestId(uint256 blockNumber) external view returns (uint256 requestId) {\n        uint256 epochBlockNumber = blockNumber - (blockNumber % EPOCH_PERIOD);\n        requestId = blockNumberToRequestId[epochBlockNumber];\n    }\n\n    /**\n     * @param blockNumber in which request was made\n     * @return randomness if not fulfilled yet returns 0\n     */\n    function getRandomness(uint256 blockNumber) external view override returns (uint256 randomness) {\n        uint256 epochBlockNumber = blockNumber - (blockNumber % EPOCH_PERIOD);\n        randomness = requestIdToRandomness[blockNumberToRequestId[epochBlockNumber]];\n    }\n\n    /**\n     * @dev Requests randomness from a block hash\n     */\n    function requestRandomness() public returns (uint256, uint256) {\n        uint256 epochBlockNumber = block.number - (block.number % EPOCH_PERIOD);\n\n        uint256 currRequestId = blockNumberToRequestId[epochBlockNumber];\n        if (currRequestId != 0) return (currRequestId, epochBlockNumber);\n\n        uint16 reqConf = uint16(uint256(EPOCH_PERIOD) - (block.number % uint256(EPOCH_PERIOD)));\n\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            // If reqConf is lower than 3, submit 3.\n            // If reqConf is higher than 200, submit 200.\n            // Otherwise, submit reqConf\n            reqConf < 3 ? 3 : reqConf > 200 ? 200 : reqConf,\n            callbackGasLimit,\n            numWords\n        );\n        blockNumberToRequestId[epochBlockNumber] = requestId;\n\n        return (requestId, epochBlockNumber);\n    }\n\n    /**\n     * @dev Callback function used by VRF Coordinator\n     */\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n        requestIdToRandomness[requestId] = randomWords[0];\n\n        emit Fulfilled(requestId, randomWords[0]);\n    }\n}\n"
    },
    "contracts/utils/Probability.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Probability {\n    /**\n     * @dev returns a sample of the random variable described by distribution\n     * @param seed an inputted random seed\n     * @param distribution array of cumulative probability distribution\n     * @return index randomly selected index of distribution\n     */\n    function probabilityDistribution(uint256 seed, uint256[] memory distribution)\n        internal\n        pure\n        returns (uint256 index)\n    {\n        uint256 seedMod = (seed % distribution[distribution.length - 1]) + 1;\n        for (uint256 j = 0; j < distribution.length; j++) if (seedMod <= distribution[j]) return j;\n\n        return 0;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract KeeperBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "contracts/random/RandomBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './IRandomBeacon.sol';\n\n/**\n * @dev abstract contract for all randomnes-generating contracts to implement.\n * All randomness-generating contracts must implement `getRandomness(uint256)`\n */\nabstract contract RandomBeacon is IRandomBeacon {\n    uint8 public override EPOCH_PERIOD;\n\n    constructor(uint8 epochPeriod) {\n        EPOCH_PERIOD = epochPeriod;\n    }\n\n    /**\n     * @dev randomness will be generated in this function. Must be implemented\n     * in child.\n     */\n    function getRandomness(uint256 blockNumber) external view virtual override returns (uint256);\n\n    /**\n     * @return currEpochBlock when current block expires\n     */\n    function epochBlockLatest() public view override returns (uint256 currEpochBlock) {\n        currEpochBlock = epochBlock(block.number);\n    }\n\n    /**\n     * @dev Return when epoch expires. Eg. blockNumber=0-99, period=100 => 100\n     */\n    function epochBlock(uint256 blockNumber) public view override returns (uint256) {\n        return blockNumber - (blockNumber % EPOCH_PERIOD) + EPOCH_PERIOD;\n    }\n}\n"
    },
    "contracts/random/IRandomBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n @dev Random beacon interface\n */\ninterface IRandomBeacon {\n    event Update(uint256 blockNumber, uint256 value);\n\n    function EPOCH_PERIOD() external view returns (uint8);\n\n    function getRandomness(uint256 blockNumber) external view returns (uint256);\n\n    function epochBlockLatest() external view returns (uint256);\n\n    function epochBlock(uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/plugins/Router/Lootbox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\nimport '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';\n\nimport '../../random/VRFBeacon.sol';\nimport '../PluginsCore.sol';\nimport '../../utils/SourceRandom.sol';\nimport '../../utils/Probability.sol';\n\n/**\n * @dev Contract module that enables implementation of unlockable lootboxes by\n * routing unlock requests to a number of deployed Crafter contracts. By\n * configuring multiple Crafter contracts that take in the lootbox (typically\n * some ERC721 token) as their sole input and each have different output asset\n * bundles, a developer can route the output of a certain lootbox to a myriad of\n * possible output bundles, effectively designating the inputted token as a\n * lootbox.\n *\n * Configuration for Crafter contracts is designated by two {Ingredient}[]. One\n * array is the `inputs` and the other is the `outputs`. The contract allows for\n * the `inputs` to be redeemed for the `outputs`, `craftableAmount` times.\n *\n * ```\n * struct Ingredient {\n *     TokenType token;\n *     ConsumableType consumableType;\n *     address contractAddr;\n *     uint256[] amounts;\n *     uint256[] tokenIds;\n * }\n * ```\n *\n * Configuration is set in the initializers and cannot be edited once the\n * contract has been launched Other configurations will require their own\n * contract to be deployed\n *\n * However, `craftableAmount` can be dynamically updated through the {deposit}\n * and {withdraw} functions which are only accessible to `DEFAULT_ADMIN_ROLE`\n *\n * Each Ingredient has a `consumableType` field.* This field is for the `inputs`\n * elements and ignored by the `outputs` elements. ERC20 and ERC1155 `inputs`\n * elements can be `unaffected` or `burned`. `unaffected` will check for\n * ownership/balance while `burned` will send the asset(s) to the `burnAddress`.\n * ERC721 inputs can be `NTime` or `burned`. `NTime` allows for a specfic\n * `tokenId` to only be used 'n times', as defined by contract deployer.\n *\n * ERC20 `inputs` and `outputs` elements should have one number in the `amounts`\n * array denoting ERC20 token amount requirement.`tokenIds` should be empty.\n * NTime consumable type ERC721 inputs should have empty `tokenIds` and\n * `amounts[0]` equal to `n` - the maximum number of times the input can be\n * used. Burned ERC721 `inputs` elements should have empty `amounts` and\n * `tokenIds` array. This contract accepts *all* `tokenId`s from an ERC721\n * contract as inputs. ERC721 `outputs` elements must have empty `amounts`\n * array. `tokenIds` array length should be `craftableAmount`. The `tokenIds`\n * array will contain the `tokenIds` to be transferred out when {craft} is\n * called. Important to note that output transfers will be from the *end* of the\n * array since `.pop()` is used.\n *\n * ERC1155 `inputs` and `outputs` elements should have the length of `amounts`\n * and `tokenIds` array be the same. The indices will be linked where each index\n * denotes how much of each ERC1155 `tokenId` is required.\n *\n * This module is used through composition. It can be deployed to create\n * crafting logic with asset contracts that are already on chain and active;\n * plug-and-play, so to speak.\n *\n * Configuration for a lootbox requires the developer enter `_crafterContracts`,\n * an address array of deployed Crafter contracts that makes up the pool of\n * potential contracts routed to.* The `probabilities` array must be of the same\n * length, as it describes the probability distribution of the random variable\n * that determines a randomly chosen contract.\n *\n * A VRFBeacon is deployed and used to inject randomness, while a Chainlink\n * Keeper is used to autonomously check if a random number has been returned by\n * the off-chain VRFBeacon coordinator. Upon receiving a random number, the\n * Keeper then calls the _unlock() function to randomly select a Crafter\n * contract and call its `craft()` function.\n */\n\ncontract Lootbox is PluginsCore, KeeperCompatibleInterface, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://Lootbox/', version)));\n\n    /**********************\n             State\n    **********************/\n\n    address[] public crafterContracts;\n    uint256[] public probabilities;\n    address public vrfBeacon;\n\n    mapping(uint256 => uint256) lootboxIdToEpochBlock;\n    uint256 public queueIndex;\n    uint256[] private upkeepQueue; //array of lootboxIds\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Create Lootbox instance\n     * @param _admin the admin/owner of the contract\n     * @param _crafterContracts array of crafterContract address, each with unique recipe\n     * @param _probabilities array of cumulative probabilities associated with\n     * using a contract from crafterContracts\n     * @param _forwarder address for trusted forwarder for open GSN integration\n     */\n    function initialize(\n        address _admin,\n        address[] calldata _crafterContracts,\n        uint8[] calldata _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) external initializer {\n        __Lootbox_init(_admin, _crafterContracts, _probabilities, _vrfBeacon, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        address[] calldata _crafterContracts,\n        uint8[] calldata _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) external onlyInitializing {\n        __Lootbox_init(_admin, _crafterContracts, _probabilities, _vrfBeacon, _forwarder);\n    }\n\n    /**\n     * @dev performs validations that `_inputs`  are valid and creates the\n     * configuration\n     */\n    function __Lootbox_init(\n        address _admin,\n        address[] calldata _crafterContracts,\n        uint8[] calldata _probabilities,\n        address _vrfBeacon,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_admin, _forwarder);\n\n        __Lootbox_init_unchained(_crafterContracts, _probabilities, _vrfBeacon);\n    }\n\n    /**\n     * @dev performs validations that `_inputs` and `_outputs` are valid and\n     * creates the configuration\n     */\n    function __Lootbox_init_unchained(\n        address[] calldata _crafterContracts,\n        uint8[] calldata _probabilities,\n        address _vrfBeacon\n    ) internal onlyInitializing {\n        require(\n            _probabilities.length == _crafterContracts.length,\n            'Lootbox.sol: lengths of probabilities and crafterContracts arrays do not match!'\n        );\n\n        crafterContracts = _crafterContracts;\n        probabilities = _probabilities;\n        vrfBeacon = _vrfBeacon;\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @dev Makes a request for random number from VRFBeacon, adds unlock\n     * request to queue - specific to lootbox token id\n     * @param lootboxId the token ID of the lootbox asset to be unlocked\n     * @return requestId the id given to the request by the VRFBeacon\n     * @return epochBlockNumber the epoch block number at the time request is made\n     */\n    function requestUnlock(uint256 lootboxId) external returns (uint256 requestId, uint256 epochBlockNumber) {\n        uint256 currEntry = lootboxIdToEpochBlock[lootboxId];\n        if (currEntry != 0) return (VRFBeacon(vrfBeacon).getRequestId(currEntry), currEntry); //Each lootbox can only be redeemed once\n\n        (requestId, epochBlockNumber) = VRFBeacon(vrfBeacon).requestRandomness();\n\n        lootboxIdToEpochBlock[lootboxId] = epochBlockNumber;\n        upkeepQueue.push(lootboxId);\n    }\n\n    /**\n     * @dev Run by Chainlink Keeper to check whether random number has been returned by VRFBeacon\n     * @return upkeepNeeded whether a random number has been returned\n     * @return performData encoding of random number and queue index\n     */\n    function checkUpkeep(\n        bytes calldata /* checkData */\n    ) external view override returns (bool upkeepNeeded, bytes memory performData) {\n        assert(queueIndex <= upkeepQueue.length);\n        if (upkeepQueue.length == queueIndex) return (false, '0x');\n\n        uint256 randomness = VRFBeacon(vrfBeacon).getRandomness(lootboxIdToEpochBlock[upkeepQueue[queueIndex]]);\n\n        if (randomness != 0) return (true, abi.encode(randomness, queueIndex));\n        return (false, '0x');\n    }\n\n    /**\n     * @dev Run by Chainlink Keeper to perform unlock on a lootbox id requiring upkeep\n     * @param performData encoding of random number and queue index via checkUpkeep\n     */\n    function performUpkeep(bytes calldata performData) external override {\n        (uint256 randomness, uint256 queueIndexRequest) = abi.decode(performData, (uint256, uint256));\n\n        //make sure that checkUpKeep hasn't run twice on the same queueIndex\n        require(queueIndexRequest == queueIndex, 'Lootbox: queueIndex already processed');\n\n        _unlock(upkeepQueue[queueIndex], randomness);\n\n        queueIndex++;\n    }\n\n    /**\n     * @dev Internal function called by performUpkeep() to call randomly-selected Crafter contract\n     * @param lootboxId the id of the lootbox to unlock\n     * @param randomSeed the random seed generated by the VRFBeacon to be used\n     * to source a random number\n     */\n    function _unlock(uint256 lootboxId, uint256 randomSeed) internal {\n        //randomly choose the crafter contract to call\n        uint256 randomNumber = SourceRandom.getSeededRandom(randomSeed, lootboxId);\n        uint256 selectedContract = Probability.probabilityDistribution(randomNumber, probabilities);\n\n        //craft outputs to msgSender\n        uint256[][] memory inputERC721Id = new uint256[][](1);\n        for (uint256 i = 0; i < 1; i++) {\n            inputERC721Id[i] = new uint256[](1);\n            inputERC721Id[0][0] = lootboxId;\n        }\n\n        address selectedCrafter = crafterContracts[selectedContract];\n\n        // low-level call to prevent from reverting. Otherwise, queueIndex will not\n        // increment and performUpkeep will be endlessly called,\n        // not allowing upkeepQueue to make progress\n\n        (bool success, bytes memory returnData) = selectedCrafter.call(\n            abi.encodePacked(abi.encodeWithSignature('craft(uint96,uint256[][])', 1, inputERC721Id), _msgSender())\n        );\n\n        if (!success) emit RouterError(lootboxId, _msgSender(), returnData);\n    }\n\n    /**\n    Getters\n    */\n\n    /**\n     * @notice Used for testing only\n     * @dev Returns epoch block during which requestUnlock was called on a lootbox ID\n     * @param lootboxId the ID of the lootbox to unlock\n     * @return uint256 the epoch block corresponding to lootboxId\n     */\n    function getEpochBlock(uint256 lootboxId) public view returns (uint256) {\n        return lootboxIdToEpochBlock[lootboxId];\n    }\n\n    /**\n     * @notice Used for testing only\n     * @dev Returns the randomly selected contract from the contracts array\n     * @param lootboxId the ID of the lootbox to unlock, used as nonce in random number generation\n     * @param randomSeed the random seed taken from checkUpkeep\n     * @return selectedContract the randomly selected contract's index in contracts array\n     */\n    function getRandomContract(uint256 lootboxId, uint256 randomSeed) external view returns (uint256 selectedContract) {\n        uint256 randomNumber = SourceRandom.getSeededRandom(randomSeed, lootboxId);\n        selectedContract = Probability.probabilityDistribution(randomNumber, probabilities);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/testing/VRFCoordinatorV2.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/BlockhashStoreInterface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol';\nimport '@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol';\nimport '@chainlink/contracts/src/v0.8/ConfirmedOwner.sol';\nimport '@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol';\n\ncontract VRFCoordinatorV2 is\n    ConfirmedOwner,\n    TypeAndVersionInterface,\n    VRFCoordinatorV2Interface,\n    ERC677ReceiverInterface\n{\n    LinkTokenInterface public immutable LINK;\n    AggregatorV3Interface public immutable LINK_ETH_FEED;\n    BlockhashStoreInterface public immutable BLOCKHASH_STORE;\n\n    // We need to maintain a list of consuming addresses.\n    // This bound ensures we are able to loop over them as needed.\n    // Should a user require more consumers, they can use multiple subscriptions.\n    uint16 public constant MAX_CONSUMERS = 100;\n    error TooManyConsumers();\n    error InsufficientBalance();\n    error InvalidConsumer(uint64 subId, address consumer);\n    error InvalidSubscription();\n    error OnlyCallableFromLink();\n    error InvalidCalldata();\n    error MustBeSubOwner(address owner);\n    error PendingRequestExists();\n    error MustBeRequestedOwner(address proposedOwner);\n    error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\n    event FundsRecovered(address to, uint256 amount);\n    // We use the subscription struct (1 word)\n    // at fulfillment time.\n    struct Subscription {\n        // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\n        uint96 balance; // Common link balance used for all consumer requests.\n        uint64 reqCount; // For fee tiers\n    }\n    // We use the config for the mgmt APIs\n    struct SubscriptionConfig {\n        address owner; // Owner can fund/withdraw/cancel the sub.\n        address requestedOwner; // For safely transferring sub ownership.\n        // Maintains the list of keys in s_consumers.\n        // We do this for 2 reasons:\n        // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\n        // 2. To be able to return the list of all consumers in getSubscription.\n        // Note that we need the s_consumers map to be able to directly check if a\n        // consumer is valid without reading all the consumers from storage.\n        address[] consumers;\n    }\n    // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\n    mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\n        private s_consumers;\n    mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\n        private s_subscriptionConfigs;\n    mapping(uint64 => Subscription) /* subId */ /* subscription */\n        private s_subscriptions;\n    // We make the sub count public so that its possible to\n    // get all the current subscriptions via getSubscription.\n    uint64 private s_currentSubId;\n    // s_totalBalance tracks the total link sent to/from\n    // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\n    // A discrepancy with this contract's link balance indicates someone\n    // sent tokens using transfer and so we may need to use recoverFunds.\n    uint96 private s_totalBalance;\n    event SubscriptionCreated(uint64 indexed subId, address owner);\n    event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n    event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\n    event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\n    event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n    event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\n    event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\n\n    // Set this maximum to 200 to give us a 56 block window to fulfill\n    // the request before requiring the block hash feeder.\n    uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\n    uint32 public constant MAX_NUM_WORDS = 500;\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n    // and some arithmetic operations.\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n    error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\n    error GasLimitTooBig(uint32 have, uint32 want);\n    error NumWordsTooBig(uint32 have, uint32 want);\n    error ProvingKeyAlreadyRegistered(bytes32 keyHash);\n    error NoSuchProvingKey(bytes32 keyHash);\n    error InvalidLinkWeiPrice(int256 linkWei);\n    error InsufficientGasForConsumer(uint256 have, uint256 want);\n    error NoCorrespondingRequest();\n    error IncorrectCommitment();\n    error BlockhashNotInStore(uint256 blockNum);\n    error PaymentTooLarge();\n    error Reentrant();\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint64 subId;\n        uint32 callbackGasLimit;\n        uint32 numWords;\n        address sender;\n    }\n    mapping(bytes32 => address) /* keyHash */ /* oracle */\n        private s_provingKeys;\n    bytes32[] private s_provingKeyHashes;\n    mapping(address => uint96) /* oracle */ /* LINK balance */\n        private s_withdrawableTokens;\n    mapping(uint256 => bytes32) /* requestID */ /* commitment */\n        private s_requestCommitments;\n    event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\n    event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\n    event RandomWordsRequested(\n        bytes32 indexed keyHash,\n        uint256 requestId,\n        uint256 preSeed,\n        uint64 indexed subId,\n        uint16 minimumRequestConfirmations,\n        uint32 callbackGasLimit,\n        uint32 numWords,\n        address indexed sender\n    );\n    event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n\n    struct Config {\n        uint16 minimumRequestConfirmations;\n        uint32 maxGasLimit;\n        // Reentrancy protection.\n        bool reentrancyLock;\n        // stalenessSeconds is how long before we consider the feed price to be stale\n        // and fallback to fallbackWeiPerUnitLink.\n        uint32 stalenessSeconds;\n        // Gas to cover oracle payment after we calculate the payment.\n        // We make it configurable in case those operations are repriced.\n        uint32 gasAfterPaymentCalculation;\n    }\n    int256 private s_fallbackWeiPerUnitLink;\n    Config private s_config;\n    FeeConfig private s_feeConfig;\n    struct FeeConfig {\n        // Flat fee charged per fulfillment in millionths of link\n        // So fee range is [0, 2^32/10^6].\n        uint32 fulfillmentFlatFeeLinkPPMTier1;\n        uint32 fulfillmentFlatFeeLinkPPMTier2;\n        uint32 fulfillmentFlatFeeLinkPPMTier3;\n        uint32 fulfillmentFlatFeeLinkPPMTier4;\n        uint32 fulfillmentFlatFeeLinkPPMTier5;\n        uint24 reqsForTier2;\n        uint24 reqsForTier3;\n        uint24 reqsForTier4;\n        uint24 reqsForTier5;\n    }\n    event ConfigSet(\n        uint16 minimumRequestConfirmations,\n        uint32 maxGasLimit,\n        uint32 stalenessSeconds,\n        uint32 gasAfterPaymentCalculation,\n        int256 fallbackWeiPerUnitLink,\n        FeeConfig feeConfig\n    );\n    struct Request {\n        uint64 subId;\n        uint32 callbackGasLimit;\n        uint32 numWords;\n    }\n    mapping(uint256 => Request) s_requests; /* requestId */ /* request */\n\n    constructor(\n        address link,\n        address blockhashStore,\n        address linkEthFeed\n    ) ConfirmedOwner(msg.sender) {\n        LINK = LinkTokenInterface(link);\n        LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n        BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\n    }\n\n    /**\n     * @notice Registers a proving key to an oracle.\n     * @param oracle address of the oracle\n     * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n     */\n    function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\n        bytes32 kh = hashOfKey(publicProvingKey);\n        if (s_provingKeys[kh] != address(0)) {\n            revert ProvingKeyAlreadyRegistered(kh);\n        }\n        s_provingKeys[kh] = oracle;\n        s_provingKeyHashes.push(kh);\n        emit ProvingKeyRegistered(kh, oracle);\n    }\n\n    /**\n     * @notice Deregisters a proving key to an oracle.\n     * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n     */\n    function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\n        bytes32 kh = hashOfKey(publicProvingKey);\n        address oracle = s_provingKeys[kh];\n        if (oracle == address(0)) {\n            revert NoSuchProvingKey(kh);\n        }\n        delete s_provingKeys[kh];\n        for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\n            if (s_provingKeyHashes[i] == kh) {\n                bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\n                // Copy last element and overwrite kh to be deleted with it\n                s_provingKeyHashes[i] = last;\n                s_provingKeyHashes.pop();\n            }\n        }\n        emit ProvingKeyDeregistered(kh, oracle);\n    }\n\n    /**\n     * @notice Returns the proving key hash key associated with this public key\n     * @param publicKey the key to return the hash of\n     */\n    function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\n        return keccak256(abi.encode(publicKey));\n    }\n\n    /**\n     * @notice Sets the configuration of the vrfv2 coordinator\n     * @param minimumRequestConfirmations global min for request confirmations\n     * @param maxGasLimit global max for request gas limit\n     * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\n     * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\n     * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\n     * @param feeConfig fee tier configuration\n     */\n    function setConfig(\n        uint16 minimumRequestConfirmations,\n        uint32 maxGasLimit,\n        uint32 stalenessSeconds,\n        uint32 gasAfterPaymentCalculation,\n        int256 fallbackWeiPerUnitLink,\n        FeeConfig memory feeConfig\n    ) external onlyOwner {\n        if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\n            revert InvalidRequestConfirmations(\n                minimumRequestConfirmations,\n                minimumRequestConfirmations,\n                MAX_REQUEST_CONFIRMATIONS\n            );\n        }\n        if (fallbackWeiPerUnitLink <= 0) {\n            revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\n        }\n        s_config = Config({\n            minimumRequestConfirmations: minimumRequestConfirmations,\n            maxGasLimit: maxGasLimit,\n            stalenessSeconds: stalenessSeconds,\n            gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n            reentrancyLock: false\n        });\n        s_feeConfig = feeConfig;\n        s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\n        emit ConfigSet(\n            minimumRequestConfirmations,\n            maxGasLimit,\n            stalenessSeconds,\n            gasAfterPaymentCalculation,\n            fallbackWeiPerUnitLink,\n            s_feeConfig\n        );\n    }\n\n    function getConfig()\n        external\n        view\n        returns (\n            uint16 minimumRequestConfirmations,\n            uint32 maxGasLimit,\n            uint32 stalenessSeconds,\n            uint32 gasAfterPaymentCalculation\n        )\n    {\n        return (\n            s_config.minimumRequestConfirmations,\n            s_config.maxGasLimit,\n            s_config.stalenessSeconds,\n            s_config.gasAfterPaymentCalculation\n        );\n    }\n\n    function getFeeConfig()\n        external\n        view\n        returns (\n            uint32 fulfillmentFlatFeeLinkPPMTier1,\n            uint32 fulfillmentFlatFeeLinkPPMTier2,\n            uint32 fulfillmentFlatFeeLinkPPMTier3,\n            uint32 fulfillmentFlatFeeLinkPPMTier4,\n            uint32 fulfillmentFlatFeeLinkPPMTier5,\n            uint24 reqsForTier2,\n            uint24 reqsForTier3,\n            uint24 reqsForTier4,\n            uint24 reqsForTier5\n        )\n    {\n        return (\n            s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\n            s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\n            s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\n            s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\n            s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\n            s_feeConfig.reqsForTier2,\n            s_feeConfig.reqsForTier3,\n            s_feeConfig.reqsForTier4,\n            s_feeConfig.reqsForTier5\n        );\n    }\n\n    function getTotalBalance() external view returns (uint256) {\n        return s_totalBalance;\n    }\n\n    function getFallbackWeiPerUnitLink() external view returns (int256) {\n        return s_fallbackWeiPerUnitLink;\n    }\n\n    /**\n     * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n     * @param subId subscription id\n     * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n     */\n    function ownerCancelSubscription(uint64 subId) external onlyOwner {\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\n    }\n\n    /**\n     * @notice Recover link sent with transfer instead of transferAndCall.\n     * @param to address to send link to\n     */\n    function recoverFunds(address to) external onlyOwner {\n        uint256 externalBalance = LINK.balanceOf(address(this));\n        uint256 internalBalance = uint256(s_totalBalance);\n        if (internalBalance > externalBalance) {\n            revert BalanceInvariantViolated(internalBalance, externalBalance);\n        }\n        if (internalBalance < externalBalance) {\n            uint256 amount = externalBalance - internalBalance;\n            LINK.transfer(to, amount);\n            emit FundsRecovered(to, amount);\n        }\n        // If the balances are equal, nothing to be done.\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function getRequestConfig()\n        external\n        view\n        override\n        returns (\n            uint16,\n            uint32,\n            bytes32[] memory\n        )\n    {\n        return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint64 subId,\n        uint16 requestConfirmations,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) external override nonReentrant returns (uint256) {\n        // Input validation using the subscription storage.\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        // Its important to ensure that the consumer is in fact who they say they\n        // are, otherwise they could use someone else's subscription balance.\n        // A nonce of 0 indicates consumer is not allocated to the sub.\n        uint64 currentNonce = s_consumers[msg.sender][subId];\n        if (currentNonce == 0) {\n            revert InvalidConsumer(subId, msg.sender);\n        }\n        // Input validation using the config storage word.\n        if (\n            requestConfirmations < s_config.minimumRequestConfirmations ||\n            requestConfirmations > MAX_REQUEST_CONFIRMATIONS\n        ) {\n            revert InvalidRequestConfirmations(\n                requestConfirmations,\n                s_config.minimumRequestConfirmations,\n                MAX_REQUEST_CONFIRMATIONS\n            );\n        }\n        // No lower bound on the requested gas limit. A user could request 0\n        // and they would simply be billed for the proof verification and wouldn't be\n        // able to do anything with the random value.\n        if (callbackGasLimit > s_config.maxGasLimit) {\n            revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\n        }\n        if (numWords > MAX_NUM_WORDS) {\n            revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\n        }\n        // Note we do not check whether the keyHash is valid to save gas.\n        // The consequence for users is that they can send requests\n        // for invalid keyHashes which will simply not be fulfilled.\n        uint64 nonce = currentNonce + 1;\n        (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\n\n        s_requestCommitments[requestId] = keccak256(\n            abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\n        );\n        emit RandomWordsRequested(\n            keyHash,\n            requestId,\n            preSeed,\n            subId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords,\n            msg.sender\n        );\n        s_consumers[msg.sender][subId] = nonce;\n\n        s_requests[requestId] = Request({subId: subId, callbackGasLimit: callbackGasLimit, numWords: numWords});\n\n        return requestId;\n    }\n\n    /**\n     * @notice Get request commitment\n     * @param requestId id of request\n     * @dev used to determine if a request is fulfilled or not\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32) {\n        return s_requestCommitments[requestId];\n    }\n\n    function computeRequestId(\n        bytes32 keyHash,\n        address sender,\n        uint64 subId,\n        uint64 nonce\n    ) private pure returns (uint256, uint256) {\n        uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\n        return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\n    }\n\n    /**\n     * @dev calls target address with exactly gasAmount gas and data as calldata\n     * or reverts if at least gasAmount gas is not available.\n     */\n    function callWithExactGas(\n        uint256 gasAmount,\n        address target,\n        bytes memory data\n    ) private returns (bool success) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let g := gas()\n            // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\n            // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\n            // We want to ensure that we revert if gasAmount >  63//64*gas available\n            // as we do not want to provide them with less, however that check itself costs\n            // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\n            // to revert if gasAmount >  63//64*gas available.\n            if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\n                revert(0, 0)\n            }\n            g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\n            // if g - g//64 <= gasAmount, revert\n            // (we subtract g//64 because of EIP-150)\n            if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\n                revert(0, 0)\n            }\n            // solidity calls check that a contract actually exists at the destination, so we do the same\n            if iszero(extcodesize(target)) {\n                revert(0, 0)\n            }\n            // call and return whether we succeeded. ignore return data\n            // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n            success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n        }\n        return success;\n    }\n\n    /*\n     * @notice Compute fee based on the request count\n     * @param reqCount number of requests\n     * @return feePPM fee in LINK PPM\n     */\n    function getFeeTier(uint64 reqCount) public view returns (uint32) {\n        FeeConfig memory fc = s_feeConfig;\n        if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\n            return fc.fulfillmentFlatFeeLinkPPMTier1;\n        }\n        if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\n            return fc.fulfillmentFlatFeeLinkPPMTier2;\n        }\n        if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\n            return fc.fulfillmentFlatFeeLinkPPMTier3;\n        }\n        if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\n            return fc.fulfillmentFlatFeeLinkPPMTier4;\n        }\n        return fc.fulfillmentFlatFeeLinkPPMTier5;\n    }\n\n    /*\n     * @notice Fulfill a randomness request\n     * @param proof contains the proof and randomness\n     * @param rc request commitment pre-image, committed to at request time\n     * @return payment amount billed to the subscription\n     * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n     */\n    function fulfillRandomWords(uint256 _requestId, address _consumer) external nonReentrant returns (uint96) {\n        uint256 startGas = gasleft();\n        uint256 numWords = 1;\n\n        Request memory rc = s_requests[_requestId];\n\n        uint256[] memory words = new uint256[](numWords);\n        for (uint256 i = 0; i < numWords; i++) {\n            words[i] = uint256(keccak256(abi.encode(_requestId, i)));\n        }\n\n        bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;\n\n        delete s_requestCommitments[_requestId];\n        VRFConsumerBaseV2 v;\n        bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, _requestId, words);\n        // Call with explicitly the amount of callback gas requested\n        // Important to not let them exhaust the gas budget and avoid oracle payment.\n        // Do not allow any non-view/non-pure coordinator functions to be called\n        // during the consumers callback code via reentrancyLock.\n        // Note that callWithExactGas will revert if we do not have sufficient gas\n        // to give the callee their requested amount.\n        s_config.reentrancyLock = true;\n        bool success = callWithExactGas(rc.callbackGasLimit, _consumer, resp);\n        s_config.reentrancyLock = false;\n\n        // Increment the req count for fee tier selection.\n        uint64 reqCount = s_subscriptions[rc.subId].reqCount;\n        s_subscriptions[rc.subId].reqCount += 1;\n\n        uint96 payment = calculatePaymentAmount(\n            startGas,\n            s_config.gasAfterPaymentCalculation,\n            getFeeTier(reqCount),\n            tx.gasprice\n        );\n        if (s_subscriptions[rc.subId].balance < payment) {\n            revert InsufficientBalance();\n        }\n        s_subscriptions[rc.subId].balance -= payment;\n        s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\n\n        emit RandomWordsFulfilled(_requestId, words[0], payment, success);\n        return payment;\n    }\n\n    // Get the amount of gas used for fulfillment\n    function calculatePaymentAmount(\n        uint256 startGas,\n        uint256 gasAfterPaymentCalculation,\n        uint32 fulfillmentFlatFeeLinkPPM,\n        uint256 weiPerUnitGas\n    ) internal view returns (uint96) {\n        int256 weiPerUnitLink;\n        weiPerUnitLink = getFeedData();\n        if (weiPerUnitLink <= 0) {\n            revert InvalidLinkWeiPrice(weiPerUnitLink);\n        }\n        // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\n        uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\n            uint256(weiPerUnitLink);\n        uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\n        if (paymentNoFee > (1e27 - fee)) {\n            revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\n        }\n        return uint96(paymentNoFee + fee);\n    }\n\n    function getFeedData() private view returns (int256) {\n        uint32 stalenessSeconds = s_config.stalenessSeconds;\n        bool staleFallback = stalenessSeconds > 0;\n        uint256 timestamp;\n        int256 weiPerUnitLink = 5733692908333333;\n        // (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\n        // // solhint-disable-next-line not-rely-on-time\n        // if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n        //     weiPerUnitLink = s_fallbackWeiPerUnitLink;\n        // }\n        return weiPerUnitLink;\n    }\n\n    /*\n     * @notice Oracle withdraw LINK earned through fulfilling requests\n     * @param recipient where to send the funds\n     * @param amount amount to withdraw\n     */\n    function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\n        if (s_withdrawableTokens[msg.sender] < amount) {\n            revert InsufficientBalance();\n        }\n        s_withdrawableTokens[msg.sender] -= amount;\n        s_totalBalance -= amount;\n        if (!LINK.transfer(recipient, amount)) {\n            revert InsufficientBalance();\n        }\n    }\n\n    function onTokenTransfer(\n        address, /* sender */\n        uint256 amount,\n        bytes calldata data\n    ) external override nonReentrant {\n        if (msg.sender != address(LINK)) {\n            revert OnlyCallableFromLink();\n        }\n        if (data.length != 32) {\n            revert InvalidCalldata();\n        }\n        uint64 subId = abi.decode(data, (uint64));\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        // We do not check that the msg.sender is the subscription owner,\n        // anyone can fund a subscription.\n        uint256 oldBalance = s_subscriptions[subId].balance;\n        s_subscriptions[subId].balance += uint96(amount);\n        s_totalBalance += uint96(amount);\n        emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\n    }\n\n    function getCurrentSubId() external view returns (uint64) {\n        return s_currentSubId;\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function getSubscription(uint64 subId)\n        external\n        view\n        override\n        returns (\n            uint96 balance,\n            uint64 reqCount,\n            address owner,\n            address[] memory consumers\n        )\n    {\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        return (\n            s_subscriptions[subId].balance,\n            s_subscriptions[subId].reqCount,\n            s_subscriptionConfigs[subId].owner,\n            s_subscriptionConfigs[subId].consumers\n        );\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function createSubscription() external override nonReentrant returns (uint64) {\n        s_currentSubId++;\n        uint64 currentSubId = s_currentSubId;\n        address[] memory consumers = new address[](0);\n        s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\n        s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\n            owner: msg.sender,\n            requestedOwner: address(0),\n            consumers: consumers\n        });\n\n        emit SubscriptionCreated(currentSubId, msg.sender);\n        return currentSubId;\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\n        external\n        override\n        onlySubOwner(subId)\n        nonReentrant\n    {\n        // Proposing to address(0) would never be claimable so don't need to check.\n        if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\n            s_subscriptionConfigs[subId].requestedOwner = newOwner;\n            emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\n        }\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\n        if (s_subscriptionConfigs[subId].owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\n            revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\n        }\n        address oldOwner = s_subscriptionConfigs[subId].owner;\n        s_subscriptionConfigs[subId].owner = msg.sender;\n        s_subscriptionConfigs[subId].requestedOwner = address(0);\n        emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n        if (s_consumers[consumer][subId] == 0) {\n            revert InvalidConsumer(subId, consumer);\n        }\n        // Note bounded by MAX_CONSUMERS\n        address[] memory consumers = s_subscriptionConfigs[subId].consumers;\n        uint256 lastConsumerIndex = consumers.length - 1;\n        for (uint256 i = 0; i < consumers.length; i++) {\n            if (consumers[i] == consumer) {\n                address last = consumers[lastConsumerIndex];\n                // Storage write to preserve last element\n                s_subscriptionConfigs[subId].consumers[i] = last;\n                // Storage remove last element\n                s_subscriptionConfigs[subId].consumers.pop();\n                break;\n            }\n        }\n        delete s_consumers[consumer][subId];\n        emit SubscriptionConsumerRemoved(subId, consumer);\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n        // Already maxed, cannot add any more consumers.\n        if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\n            revert TooManyConsumers();\n        }\n        if (s_consumers[consumer][subId] != 0) {\n            // Idempotence - do nothing if already added.\n            // Ensures uniqueness in s_subscriptions[subId].consumers.\n            return;\n        }\n        // Initialize the nonce to 1, indicating the consumer is allocated.\n        s_consumers[consumer][subId] = 1;\n        s_subscriptionConfigs[subId].consumers.push(consumer);\n\n        emit SubscriptionConsumerAdded(subId, consumer);\n    }\n\n    /**\n     * @inheritdoc VRFCoordinatorV2Interface\n     */\n    function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\n        cancelSubscriptionHelper(subId, to);\n    }\n\n    function cancelSubscriptionHelper(uint64 subId, address to) private nonReentrant {\n        SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n        Subscription memory sub = s_subscriptions[subId];\n        uint96 balance = sub.balance;\n        // Note bounded by MAX_CONSUMERS;\n        // If no consumers, does nothing.\n        for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n            delete s_consumers[subConfig.consumers[i]][subId];\n        }\n        delete s_subscriptionConfigs[subId];\n        delete s_subscriptions[subId];\n        s_totalBalance -= balance;\n        if (!LINK.transfer(to, uint256(balance))) {\n            revert InsufficientBalance();\n        }\n        emit SubscriptionCanceled(subId, to, balance);\n    }\n\n    modifier onlySubOwner(uint64 subId) {\n        address owner = s_subscriptionConfigs[subId].owner;\n        if (owner == address(0)) {\n            revert InvalidSubscription();\n        }\n        if (msg.sender != owner) {\n            revert MustBeSubOwner(owner);\n        }\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (s_config.reentrancyLock) {\n            revert Reentrant();\n        }\n        _;\n    }\n\n    /**\n     * @notice The type and version of this contract\n     * @return Type and version string\n     */\n    function typeAndVersion() external pure virtual override returns (string memory) {\n        return 'VRFCoordinatorV2 1.0.0';\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/BlockhashStoreInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface BlockhashStoreInterface {\n  function getBlockhash(uint256 number) external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract TypeAndVersionInterface {\n  function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface ERC677ReceiverInterface {\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "contracts/proxy/ERC1167/ERC1167Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ClonesUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport 'hardhat/console.sol';\n\n/**\n * @dev ERC1167 Minimal Proxy Factory\n */\ncontract ERC1167Factory is ContextUpgradeable {\n    using AddressUpgradeable for address;\n\n    event NewClone(address instance, address implementation, bytes32 salt);\n\n    function clone(address implementation, bytes memory data) public returns (address instance) {\n        instance = ClonesUpgradeable.clone(implementation);\n\n        //data is optional\n        if (data.length > 0) instance.functionCall(data, 'ERC1167Factory: Failed to call the proxy');\n\n        emit NewClone(instance, implementation, bytes32(0));\n    }\n\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        bytes memory data\n    ) public returns (address instance) {\n        //Salt init data\n        salt = keccak256(abi.encodePacked(salt, _msgSender(), data));\n        instance = ClonesUpgradeable.cloneDeterministic(implementation, salt);\n\n        //data is optional\n        if (data.length > 0) instance.functionCall(data, 'ERC1167Factory: Failed to call the proxy');\n\n        emit NewClone(instance, implementation, salt);\n    }\n\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        bytes memory data\n    ) public view returns (address predicted) {\n        //Salt init data\n        salt = keccak256(abi.encodePacked(salt, _msgSender(), data));\n        predicted = ClonesUpgradeable.predictDeterministicAddress(implementation, salt);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/paymasters/NFTOwnershipPaymaster.sol": {
      "content": "// // SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.9;\nimport 'hardhat/console.sol';\n\nimport '@opengsn/contracts/src/BasePaymaster.sol';\nimport '@opengsn/contracts/src/forwarder/IForwarder.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\nimport './OwlPaymasterBase.sol';\n\n/**\n * @dev This paymaster will approve transactions sent through a relay provider\n * if the client owns an approved ERC721 token in a collection. The paymaster\n * takes in an address of a collection of acceptable tokenIds that a client\n * can own to be able to complete a gasless transaction. A mapping also keeps\n * track of how many times a specific tokenId is used to get approved, and there\n * is a limit on how many times each tokenId can be used.\n */\ncontract NFTOwnershipPaymaster is OwlPaymasterBase {\n    event PreRelayed();\n    event PostRelayed();\n\n    IERC721Upgradeable public acceptableToken; //address for NFT that is acceptable for approving a transaction\n    address public payer; //user who wants to approve a transaction\n    uint256 public limit; //maximum number of times a user can transact\n\n    mapping(uint256 => uint256) numTimes; //keeps track how many times a tokenId has minted\n    mapping(address => uint256) gasSpent; //maps a user to how much gas it has cost the paymaster\n\n    /**\n     * @dev initializes a paymaster contract\n     * @param _admin admin of the paymaster\n     * @param _acceptableToken address for acceptable token contract for approving transactions\n     * @param _limit the maximum number of times a tokenId can be used to approve a transaction\n     * @param _forwarder address for the trusted forwarder for open GSN\n     */\n    function initialize(\n        address _admin,\n        address _acceptableToken,\n        uint256 _limit,\n        address _forwarder\n    ) external initializer {\n        __NFTOwnershipPaymaster_init(_admin, _acceptableToken, _limit, _forwarder);\n    }\n\n    function proxyinitialize(\n        address _admin,\n        address _acceptableToken,\n        uint256 _limit,\n        address _forwarder\n    ) external onlyInitializing {\n        __NFTOwnershipPaymaster_init(_admin, _acceptableToken, _limit, _forwarder);\n    }\n\n    function __NFTOwnershipPaymaster_init(\n        address _admin,\n        address _acceptableToken,\n        uint256 _limit,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_admin, _forwarder);\n        __NFTOwnershipPaymaster_init_unchained(_acceptableToken, _limit);\n    }\n\n    function __NFTOwnershipPaymaster_init_unchained(address _acceptableToken, uint256 _limit)\n        internal\n        onlyInitializing\n    {\n        acceptableToken = IERC721Upgradeable(_acceptableToken);\n        limit = _limit;\n    }\n\n    /**\n     * @dev function that performs all access control. It verifies that\n     * the client owns an acceptable token in the approved collection.\n     * it also ensures that the tokenId usage has not reached it's limit\n     */\n    function preRelayedCall(\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 maxPossibleGas\n    ) external virtual override returns (bytes memory context, bool revertOnRecipientRevert) {\n        require(relayRequest.relayData.paymasterData.length == 0, 'paymasterData: invalid length');\n        (signature, maxPossibleGas);\n\n        payer = relayRequest.request.from;\n\n        uint256 tokenId = abi.decode(approvalData, (uint256));\n\n        require(gasSpent[payer] <= this.PAYMASTER_ACCEPTANCE_BUDGET(), 'User reached gas limit');\n\n        require(numTimes[tokenId] < limit, 'TokenId reached minting limit');\n        numTimes[tokenId]++;\n\n        require(acceptableToken.ownerOf(tokenId) == payer, 'User does not own NFT');\n\n        return ('', false);\n    }\n\n    /**\n     * @dev function that performs all bookkeeping after a function call\n     * has been made.\n     */\n    function postRelayedCall(\n        bytes calldata context,\n        bool success,\n        uint256 gasUseWithoutPost,\n        GsnTypes.RelayData calldata relayData\n    ) external virtual override {\n        if (success) {\n            gasSpent[payer] += gasUseWithoutPost;\n        }\n        (context, success, gasUseWithoutPost, relayData);\n    }\n\n    /**\n     * @dev function that is required for open GSN paymasters\n     */\n    function versionPaymaster() external view virtual override returns (string memory) {\n        return '2.2.0+owlprotocol.paymasters.nftownershippaymaster';\n    }\n\n    function getNumTransactions(uint256 tokenId) external view returns (uint256) {\n        return numTimes[tokenId];\n    }\n\n    function getGasSpent(address user) external view returns (uint256) {\n        return gasSpent[user];\n    }\n}\n"
    },
    "@opengsn/contracts/src/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./utils/GsnTypes.sol\";\nimport \"./interfaces/IPaymaster.sol\";\nimport \"./interfaces/IRelayHub.sol\";\nimport \"./utils/GsnEip712Library.sol\";\nimport \"./forwarder/IForwarder.sol\";\n\n/**\n * Abstract base class to be inherited by a concrete Paymaster\n * A subclass must implement:\n *  - preRelayedCall\n *  - postRelayedCall\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n\n    IRelayHub internal relayHub;\n    address private _trustedForwarder;\n\n    function getHubAddr() public override view returns (address) {\n        return address(relayHub);\n    }\n\n    //overhead of forwarder verify+signature, plus hub overhead.\n    uint256 constant public FORWARDER_HUB_OVERHEAD = 50000;\n\n    //These parameters are documented in IPaymaster.GasAndDataLimits\n    uint256 constant public PRE_RELAYED_CALL_GAS_LIMIT = 100000;\n    uint256 constant public POST_RELAYED_CALL_GAS_LIMIT = 110000;\n    uint256 constant public PAYMASTER_ACCEPTANCE_BUDGET = PRE_RELAYED_CALL_GAS_LIMIT + FORWARDER_HUB_OVERHEAD;\n    uint256 constant public CALLDATA_SIZE_LIMIT = 10500;\n\n    function getGasAndDataLimits()\n    public\n    override\n    virtual\n    view\n    returns (\n        IPaymaster.GasAndDataLimits memory limits\n    ) {\n        return IPaymaster.GasAndDataLimits(\n            PAYMASTER_ACCEPTANCE_BUDGET,\n            PRE_RELAYED_CALL_GAS_LIMIT,\n            POST_RELAYED_CALL_GAS_LIMIT,\n            CALLDATA_SIZE_LIMIT\n        );\n    }\n\n    // this method must be called from preRelayedCall to validate that the forwarder\n    // is approved by the paymaster as well as by the recipient contract.\n    function _verifyForwarder(GsnTypes.RelayRequest calldata relayRequest)\n    public\n    view\n    {\n        require(address(_trustedForwarder) == relayRequest.relayData.forwarder, \"Forwarder is not trusted\");\n        GsnEip712Library.verifyForwarderTrusted(relayRequest);\n    }\n\n    /*\n     * modifier to be used by recipients as access control protection for preRelayedCall & postRelayedCall\n     */\n    modifier relayHubOnly() {\n        require(msg.sender == getHubAddr(), \"can only be called by RelayHub\");\n        _;\n    }\n\n    function setRelayHub(IRelayHub hub) public onlyOwner {\n        relayHub = hub;\n    }\n\n    function setTrustedForwarder(address forwarder) public virtual onlyOwner {\n        _trustedForwarder = forwarder;\n    }\n\n    function trustedForwarder() public virtual view override returns (address){\n        return _trustedForwarder;\n    }\n\n\n    /// check current deposit on relay hub.\n    function getRelayHubDeposit()\n    public\n    override\n    view\n    returns (uint) {\n        return relayHub.balanceOf(address(this));\n    }\n\n    // any money moved into the paymaster is transferred as a deposit.\n    // This way, we don't need to understand the RelayHub API in order to replenish\n    // the paymaster.\n    receive() external virtual payable {\n        require(address(relayHub) != address(0), \"relay hub address not set\");\n        relayHub.depositFor{value:msg.value}(address(this));\n    }\n\n    /// withdraw deposit from relayHub\n    function withdrawRelayHubDepositTo(uint amount, address payable target) public onlyOwner {\n        relayHub.withdraw(amount, target);\n    }\n}\n"
    },
    "@opengsn/contracts/src/forwarder/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IForwarder {\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n        uint256 validUntil;\n    }\n\n    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\n\n    event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);\n\n    function getNonce(address from)\n    external view\n    returns(uint256);\n\n    /**\n     * verify the transaction would execute.\n     * validate the signature and the nonce of the request.\n     * revert if either signature or nonce are incorrect.\n     * also revert if domainSeparator or requestTypeHash are not registered.\n     */\n    function verify(\n        ForwardRequest calldata forwardRequest,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * execute a transaction\n     * @param forwardRequest - all transaction parameters\n     * @param domainSeparator - domain used when signing this request\n     * @param requestTypeHash - request type used when signing this request.\n     * @param suffixData - the extension data used when signing this request.\n     * @param signature - signature to validate.\n     *\n     * the transaction is verified, and then executed.\n     * the success and ret of \"call\" are returned.\n     * This method would revert only verification errors. target errors\n     * are reported using the returned \"success\" and ret string\n     */\n    function execute(\n        ForwardRequest calldata forwardRequest,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata signature\n    )\n    external payable\n    returns (bool success, bytes memory ret);\n\n    /**\n     * Register a new Request typehash.\n     * @param typeName - the name of the request type.\n     * @param typeSuffix - any extra data after the generic params.\n     *  (must add at least one param. The generic ForwardRequest type is always registered by the constructor)\n     */\n    function registerRequestType(string calldata typeName, string calldata typeSuffix) external;\n\n    /**\n     * Register a new domain separator.\n     * The domain separator must have the following fields: name,version,chainId, verifyingContract.\n     * the chainId is the current network's chainId, and the verifyingContract is this forwarder.\n     * This method is given the domain name and version to create and register the domain separator value.\n     * @param name the domain's display name\n     * @param version the domain/protocol version\n     */\n    function registerDomainSeparator(string calldata name, string calldata version) external;\n}\n"
    },
    "contracts/paymasters/OwlPaymasterBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '../OwlBase.sol';\nimport '@opengsn/contracts/src/BasePaymaster.sol';\n\n/**\n * @dev this abstract contract is the base for all Owl Paymasters.\n * It inherits from BasePaymaster implemented by Open GSN and it\n * also inherits from OwlBase to allow for creating Beacon proxies\n * and instances.\n */\nabstract contract OwlPaymasterBase is OwlBase, BasePaymaster {\n    function _msgSender() internal view virtual override(OwlBase, Context) returns (address ret) {\n        return OwlBase._msgSender();\n    }\n\n    function _msgData() internal view virtual override(OwlBase, Context) returns (bytes calldata) {\n        return OwlBase._msgData();\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@opengsn/contracts/src/utils/GsnTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../forwarder/IForwarder.sol\";\n\ninterface GsnTypes {\n    /// @notice gasPrice, pctRelayFee and baseRelayFee must be validated inside of the paymaster's preRelayedCall in order not to overpay\n    struct RelayData {\n        uint256 gasPrice;\n        uint256 pctRelayFee;\n        uint256 baseRelayFee;\n        address relayWorker;\n        address paymaster;\n        address forwarder;\n        bytes paymasterData;\n        uint256 clientId;\n    }\n\n    //note: must start with the ForwardRequest to be an extension of the generic forwarder\n    struct RelayRequest {\n        IForwarder.ForwardRequest request;\n        RelayData relayData;\n    }\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport \"../utils/GsnTypes.sol\";\n\ninterface IPaymaster {\n\n    /**\n     * @param acceptanceBudget -\n     *      Paymaster expected gas budget to accept (or reject) a request\n     *      This a gas required by any calculations that might need to reject the\n     *      transaction, by preRelayedCall, forwarder and recipient.\n     *      See value in BasePaymaster.PAYMASTER_ACCEPTANCE_BUDGET\n     *      Transaction that gets rejected above that gas usage is on the paymaster's expense.\n     *      As long this value is above preRelayedCallGasLimit (see defaults in BasePaymaster), the\n     *      Paymaster is guaranteed it will never pay for rejected transactions.\n     *      If this value is below preRelayedCallGasLimt, it might might make Paymaster open to a \"griefing\" attack.\n     *\n     *      Specifying value too high might make the call rejected by some relayers.\n     *\n     *      From a Relay's point of view, this is the highest gas value a paymaster might \"grief\" the relay,\n     *      since the paymaster will pay anything above that (regardless if the tx reverts)\n     *\n     * @param preRelayedCallGasLimit - the max gas usage of preRelayedCall. any revert (including OOG)\n     *      of preRelayedCall is a reject by the paymaster.\n     *      as long as acceptanceBudget is above preRelayedCallGasLimit, any such revert (including OOG)\n     *      is not payed by the paymaster.\n     * @param postRelayedCallGasLimit - the max gas usage of postRelayedCall.\n     *      note that an OOG will revert the transaction, but the paymaster already committed to pay,\n     *      so the relay will get compensated, at the expense of the paymaster\n     */\n    struct GasAndDataLimits {\n        uint256 acceptanceBudget;\n        uint256 preRelayedCallGasLimit;\n        uint256 postRelayedCallGasLimit;\n        uint256 calldataSizeLimit;\n    }\n\n    /**\n     * Return the Gas Limits and msg.data max size constants used by the Paymaster.\n     */\n    function getGasAndDataLimits()\n    external\n    view\n    returns (\n        GasAndDataLimits memory limits\n    );\n\n    function trustedForwarder() external view returns (address);\n\n/**\n * return the relayHub of this contract.\n */\n    function getHubAddr() external view returns (address);\n\n    /**\n     * Can be used to determine if the contract can pay for incoming calls before making any.\n     * @return the paymaster's deposit in the RelayHub.\n     */\n    function getRelayHubDeposit() external view returns (uint256);\n\n    /**\n     * Called by Relay (and RelayHub), to validate if the paymaster agrees to pay for this call.\n     *\n     * MUST be protected with relayHubOnly() in case it modifies state.\n     *\n     * The Paymaster rejects by the following \"revert\" operations\n     *  - preRelayedCall() method reverts\n     *  - the forwarder reverts because of nonce or signature error\n     *  - the paymaster returned \"rejectOnRecipientRevert\", and the recipient contract reverted.\n     * In any of the above cases, all paymaster calls (and recipient call) are reverted.\n     * In any other case, the paymaster agrees to pay for the gas cost of the transaction (note\n     *  that this includes also postRelayedCall revert)\n     *\n     * The rejectOnRecipientRevert flag means the Paymaster \"delegate\" the rejection to the recipient\n     *  code.  It also means the Paymaster trust the recipient to reject fast: both preRelayedCall,\n     *  forwarder check and receipient checks must fit into the GasLimits.acceptanceBudget,\n     *  otherwise the TX is paid by the Paymaster.\n     *\n     *  @param relayRequest - the full relay request structure\n     *  @param signature - user's EIP712-compatible signature of the {@link relayRequest}.\n     *              Note that in most cases the paymaster shouldn't try use it at all. It is always checked\n     *              by the forwarder immediately after preRelayedCall returns.\n     *  @param approvalData - extra dapp-specific data (e.g. signature from trusted party)\n     *  @param maxPossibleGas - based on values returned from {@link getGasAndDataLimits},\n     *         the RelayHub will calculate the maximum possible amount of gas the user may be charged for.\n     *         In order to convert this value to wei, the Paymaster has to call \"relayHub.calculateCharge()\"\n     *  return:\n     *      a context to be passed to postRelayedCall\n     *      rejectOnRecipientRevert - TRUE if paymaster want to reject the TX if the recipient reverts.\n     *          FALSE means that rejects by the recipient will be completed on chain, and paid by the paymaster.\n     *          (note that in the latter case, the preRelayedCall and postRelayedCall are not reverted).\n     */\n    function preRelayedCall(\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 maxPossibleGas\n    )\n    external\n    returns (bytes memory context, bool rejectOnRecipientRevert);\n\n    /**\n     * This method is called after the actual relayed function call.\n     * It may be used to record the transaction (e.g. charge the caller by some contract logic) for this call.\n     *\n     * MUST be protected with relayHubOnly() in case it modifies state.\n     *\n     * @param context - the call context, as returned by the preRelayedCall\n     * @param success - true if the relayed call succeeded, false if it reverted\n     * @param gasUseWithoutPost - the actual amount of gas used by the entire transaction, EXCEPT\n     *        the gas used by the postRelayedCall itself.\n     * @param relayData - the relay params of the request. can be used by relayHub.calculateCharge()\n     *\n     * Revert in this functions causes a revert of the client's relayed call (and preRelayedCall(), but the Paymaster\n     * is still committed to pay the relay for the entire transaction.\n     */\n    function postRelayedCall(\n        bytes calldata context,\n        bool success,\n        uint256 gasUseWithoutPost,\n        GsnTypes.RelayData calldata relayData\n    ) external;\n\n    function versionPaymaster() external view returns (string memory);\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IRelayHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport \"../utils/GsnTypes.sol\";\nimport \"./IStakeManager.sol\";\n\ninterface IRelayHub {\n    struct RelayHubConfig {\n        // maximum number of worker accounts allowed per manager\n        uint256 maxWorkerCount;\n        // Gas set aside for all relayCall() instructions to prevent unexpected out-of-gas exceptions\n        uint256 gasReserve;\n        // Gas overhead to calculate gasUseWithoutPost\n        uint256 postOverhead;\n        // Gas cost of all relayCall() instructions after actual 'calculateCharge()'\n        // Assume that relay has non-zero balance (costs 15'000 more otherwise).\n        uint256 gasOverhead;\n        // Maximum funds that can be deposited at once. Prevents user error by disallowing large deposits.\n        uint256 maximumRecipientDeposit;\n        // Minimum unstake delay blocks of a relay manager's stake on the StakeManager\n        uint256 minimumUnstakeDelay;\n        // Minimum stake a relay can have. An attack on the network will never cost less than half this value.\n        uint256 minimumStake;\n        // relayCall()'s msg.data upper bound gas cost per byte\n        uint256 dataGasCostPerByte;\n        // relayCalls() minimal gas overhead when calculating cost of putting tx on chain.\n        uint256 externalCallDataCostOverhead;\n    }\n\n    event RelayHubConfigured(RelayHubConfig config);\n\n    /// Emitted when a relay server registers or updates its details\n    /// Looking at these events lets a client discover relay servers\n    event RelayServerRegistered(\n        address indexed relayManager,\n        uint256 baseRelayFee,\n        uint256 pctRelayFee,\n        string relayUrl\n    );\n\n    /// Emitted when relays are added by a relayManager\n    event RelayWorkersAdded(\n        address indexed relayManager,\n        address[] newRelayWorkers,\n        uint256 workersCount\n    );\n\n    /// Emitted when an account withdraws funds from RelayHub.\n    event Withdrawn(\n        address indexed account,\n        address indexed dest,\n        uint256 amount\n    );\n\n    /// Emitted when depositFor is called, including the amount and account that was funded.\n    event Deposited(\n        address indexed paymaster,\n        address indexed from,\n        uint256 amount\n    );\n\n    /// Emitted when an attempt to relay a call fails and Paymaster does not accept the transaction.\n    /// The actual relayed call was not executed, and the recipient not charged.\n    /// @param reason contains a revert reason returned from preRelayedCall or forwarder.\n    event TransactionRejectedByPaymaster(\n        address indexed relayManager,\n        address indexed paymaster,\n        address indexed from,\n        address to,\n        address relayWorker,\n        bytes4 selector,\n        uint256 innerGasUsed,\n        bytes reason\n    );\n\n    /// Emitted when a transaction is relayed. Note that the actual encoded function might be reverted: this will be\n    /// indicated in the status field.\n    /// Useful when monitoring a relay's operation and relayed calls to a contract.\n    /// Charge is the ether value deducted from the recipient's balance, paid to the relay's manager.\n    event TransactionRelayed(\n        address indexed relayManager,\n        address indexed relayWorker,\n        address indexed from,\n        address to,\n        address paymaster,\n        bytes4 selector,\n        RelayCallStatus status,\n        uint256 charge\n    );\n\n    event TransactionResult(\n        RelayCallStatus status,\n        bytes returnValue\n    );\n\n    event HubDeprecated(uint256 fromBlock);\n\n    /// Reason error codes for the TransactionRelayed event\n    /// @param OK - the transaction was successfully relayed and execution successful - never included in the event\n    /// @param RelayedCallFailed - the transaction was relayed, but the relayed call failed\n    /// @param RejectedByPreRelayed - the transaction was not relayed due to preRelatedCall reverting\n    /// @param RejectedByForwarder - the transaction was not relayed due to forwarder check (signature,nonce)\n    /// @param PostRelayedFailed - the transaction was relayed and reverted due to postRelatedCall reverting\n    /// @param PaymasterBalanceChanged - the transaction was relayed and reverted due to the paymaster balance change\n    enum RelayCallStatus {\n        OK,\n        RelayedCallFailed,\n        RejectedByPreRelayed,\n        RejectedByForwarder,\n        RejectedByRecipientRevert,\n        PostRelayedFailed,\n        PaymasterBalanceChanged\n    }\n\n    /// Add new worker addresses controlled by sender who must be a staked Relay Manager address.\n    /// Emits a RelayWorkersAdded event.\n    /// This function can be called multiple times, emitting new events\n    function addRelayWorkers(address[] calldata newRelayWorkers) external;\n\n    function registerRelayServer(uint256 baseRelayFee, uint256 pctRelayFee, string calldata url) external;\n\n    // Balance management\n\n    /// Deposits ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only\n    /// be withdrawn by the contract itself, by calling withdraw.\n    /// Emits a Deposited event.\n    function depositFor(address target) external payable;\n\n    /// Withdraws from an account's balance, sending it back to it. Relay managers call this to retrieve their revenue, and\n    /// contracts can also use it to reduce their funding.\n    /// Emits a Withdrawn event.\n    function withdraw(uint256 amount, address payable dest) external;\n\n    // Relaying\n\n\n    /// Relays a transaction. For this to succeed, multiple conditions must be met:\n    ///  - Paymaster's \"preRelayCall\" method must succeed and not revert\n    ///  - the sender must be a registered Relay Worker that the user signed\n    ///  - the transaction's gas price must be equal or larger than the one that was signed by the sender\n    ///  - the transaction must have enough gas to run all internal transactions if they use all gas available to them\n    ///  - the Paymaster must have enough balance to pay the Relay Worker for the scenario when all gas is spent\n    ///\n    /// If all conditions are met, the call will be relayed and the recipient charged.\n    ///\n    /// Arguments:\n    /// @param maxAcceptanceBudget - max valid value for paymaster.getGasLimits().acceptanceBudget\n    /// @param relayRequest - all details of the requested relayed call\n    /// @param signature - client's EIP-712 signature over the relayRequest struct\n    /// @param approvalData: dapp-specific data forwarded to preRelayedCall.\n    ///        This value is *not* verified by the Hub. For example, it can be used to pass a signature to the Paymaster\n    /// @param externalGasLimit - the value passed as gasLimit to the transaction.\n    ///\n    /// Emits a TransactionRelayed event.\n    function relayCall(\n        uint maxAcceptanceBudget,\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint externalGasLimit\n    )\n    external\n    returns (bool paymasterAccepted, bytes memory returnValue);\n\n    function penalize(address relayWorker, address payable beneficiary) external;\n\n    function setConfiguration(RelayHubConfig memory _config) external;\n\n    // Deprecate hub (reverting relayCall()) from block number 'fromBlock'\n    // Can only be called by owner\n    function deprecateHub(uint256 fromBlock) external;\n\n    /// The fee is expressed as a base fee in wei plus percentage on actual charge.\n    /// E.g. a value of 40 stands for a 40% fee, so the recipient will be\n    /// charged for 1.4 times the spent amount.\n    function calculateCharge(uint256 gasUsed, GsnTypes.RelayData calldata relayData) external view returns (uint256);\n\n    /* getters */\n\n    /// Returns the whole hub configuration\n    function getConfiguration() external view returns (RelayHubConfig memory config);\n\n    function calldataGasCost(uint256 length) external view returns (uint256);\n\n    function workerToManager(address worker) external view returns(address);\n\n    function workerCount(address manager) external view returns(uint256);\n\n    /// Returns an account's deposits. It can be either a deposit of a paymaster, or a revenue of a relay manager.\n    function balanceOf(address target) external view returns (uint256);\n\n    function stakeManager() external view returns (IStakeManager);\n\n    function penalizer() external view returns (address);\n\n    /// Uses StakeManager info to decide if the Relay Manager can be considered staked\n    /// @return true if stake size and delay satisfy all requirements\n    function isRelayManagerStaked(address relayManager) external view returns(bool);\n\n    // Checks hubs' deprecation status\n    function isDeprecated() external view returns (bool);\n\n    // Returns the block number from which the hub no longer allows relaying calls.\n    function deprecationBlock() external view returns (uint256);\n\n    /// @return a SemVer-compliant version of the hub contract\n    function versionHub() external view returns (string memory);\n}\n\n"
    },
    "@opengsn/contracts/src/utils/GsnEip712Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../utils/GsnTypes.sol\";\nimport \"../interfaces/IRelayRecipient.sol\";\nimport \"../forwarder/IForwarder.sol\";\n\nimport \"./GsnUtils.sol\";\n\n/**\n * Bridge Library to map GSN RelayRequest into a call of a Forwarder\n */\nlibrary GsnEip712Library {\n    // maximum length of return value/revert reason for 'execute' method. Will truncate result if exceeded.\n    uint256 private constant MAX_RETURN_SIZE = 1024;\n\n    //copied from Forwarder (can't reference string constants even from another library)\n    string public constant GENERIC_PARAMS = \"address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntil\";\n\n    bytes public constant RELAYDATA_TYPE = \"RelayData(uint256 gasPrice,uint256 pctRelayFee,uint256 baseRelayFee,address relayWorker,address paymaster,address forwarder,bytes paymasterData,uint256 clientId)\";\n\n    string public constant RELAY_REQUEST_NAME = \"RelayRequest\";\n    string public constant RELAY_REQUEST_SUFFIX = string(abi.encodePacked(\"RelayData relayData)\", RELAYDATA_TYPE));\n\n    bytes public constant RELAY_REQUEST_TYPE = abi.encodePacked(\n        RELAY_REQUEST_NAME,\"(\",GENERIC_PARAMS,\",\", RELAY_REQUEST_SUFFIX);\n\n    bytes32 public constant RELAYDATA_TYPEHASH = keccak256(RELAYDATA_TYPE);\n    bytes32 public constant RELAY_REQUEST_TYPEHASH = keccak256(RELAY_REQUEST_TYPE);\n\n\n    struct EIP712Domain {\n        string name;\n        string version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    function splitRequest(\n        GsnTypes.RelayRequest calldata req\n    )\n    internal\n    pure\n    returns (\n        bytes memory suffixData\n    ) {\n        suffixData = abi.encode(\n            hashRelayData(req.relayData));\n    }\n\n    //verify that the recipient trusts the given forwarder\n    // MUST be called by paymaster\n    function verifyForwarderTrusted(GsnTypes.RelayRequest calldata relayRequest) internal view {\n        (bool success, bytes memory ret) = relayRequest.request.to.staticcall(\n            abi.encodeWithSelector(\n                IRelayRecipient.isTrustedForwarder.selector, relayRequest.relayData.forwarder\n            )\n        );\n        require(success, \"isTrustedForwarder: reverted\");\n        require(ret.length == 32, \"isTrustedForwarder: bad response\");\n        require(abi.decode(ret, (bool)), \"invalid forwarder for recipient\");\n    }\n\n    function verifySignature(GsnTypes.RelayRequest calldata relayRequest, bytes calldata signature) internal view {\n        (bytes memory suffixData) = splitRequest(relayRequest);\n        bytes32 _domainSeparator = domainSeparator(relayRequest.relayData.forwarder);\n        IForwarder forwarder = IForwarder(payable(relayRequest.relayData.forwarder));\n        forwarder.verify(relayRequest.request, _domainSeparator, RELAY_REQUEST_TYPEHASH, suffixData, signature);\n    }\n\n    function verify(GsnTypes.RelayRequest calldata relayRequest, bytes calldata signature) internal view {\n        verifyForwarderTrusted(relayRequest);\n        verifySignature(relayRequest, signature);\n    }\n\n    function execute(GsnTypes.RelayRequest calldata relayRequest, bytes calldata signature) internal returns (bool forwarderSuccess, bool callSuccess, bytes memory ret) {\n        (bytes memory suffixData) = splitRequest(relayRequest);\n        bytes32 _domainSeparator = domainSeparator(relayRequest.relayData.forwarder);\n        /* solhint-disable-next-line avoid-low-level-calls */\n        (forwarderSuccess, ret) = relayRequest.relayData.forwarder.call(\n            abi.encodeWithSelector(IForwarder.execute.selector,\n            relayRequest.request, _domainSeparator, RELAY_REQUEST_TYPEHASH, suffixData, signature\n        ));\n        if ( forwarderSuccess ) {\n\n          //decode return value of execute:\n          (callSuccess, ret) = abi.decode(ret, (bool, bytes));\n        }\n        truncateInPlace(ret);\n    }\n\n    //truncate the given parameter (in-place) if its length is above the given maximum length\n    // do nothing otherwise.\n    //NOTE: solidity warns unless the method is marked \"pure\", but it DOES modify its parameter.\n    function truncateInPlace(bytes memory data) internal pure {\n        MinLibBytes.truncateInPlace(data, MAX_RETURN_SIZE);\n    }\n\n    function domainSeparator(address forwarder) internal view returns (bytes32) {\n        return hashDomain(EIP712Domain({\n            name : \"GSN Relayed Transaction\",\n            version : \"2\",\n            chainId : getChainID(),\n            verifyingContract : forwarder\n            }));\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function hashDomain(EIP712Domain memory req) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(bytes(req.name)),\n                keccak256(bytes(req.version)),\n                req.chainId,\n                req.verifyingContract));\n    }\n\n    function hashRelayData(GsnTypes.RelayData calldata req) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                RELAYDATA_TYPEHASH,\n                req.gasPrice,\n                req.pctRelayFee,\n                req.baseRelayFee,\n                req.relayWorker,\n                req.paymaster,\n                req.forwarder,\n                keccak256(req.paymasterData),\n                req.clientId\n            ));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStakeManager {\n\n    /// Emitted when a stake or unstakeDelay are initialized or increased\n    event StakeAdded(\n        address indexed relayManager,\n        address indexed owner,\n        uint256 stake,\n        uint256 unstakeDelay\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(\n        address indexed relayManager,\n        address indexed owner,\n        uint256 withdrawBlock\n    );\n\n    /// Emitted when owner withdraws relayManager funds\n    event StakeWithdrawn(\n        address indexed relayManager,\n        address indexed owner,\n        uint256 amount\n    );\n\n    /// Emitted when an authorized Relay Hub penalizes a relayManager\n    event StakePenalized(\n        address indexed relayManager,\n        address indexed beneficiary,\n        uint256 reward\n    );\n\n    event HubAuthorized(\n        address indexed relayManager,\n        address indexed relayHub\n    );\n\n    event HubUnauthorized(\n        address indexed relayManager,\n        address indexed relayHub,\n        uint256 removalBlock\n    );\n\n    event OwnerSet(\n        address indexed relayManager,\n        address indexed owner\n    );\n\n    /// @param stake - amount of ether staked for this relay\n    /// @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'\n    /// @param withdrawBlock - first block number 'withdraw' will be callable, or zero if the unlock has not been called\n    /// @param owner - address that receives revenue and manages relayManager's stake\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelay;\n        uint256 withdrawBlock;\n        address payable owner;\n    }\n\n    struct RelayHubInfo {\n        uint256 removalBlock;\n    }\n\n    /// Set the owner of a Relay Manager. Called only by the RelayManager itself.\n    /// Note that owners cannot transfer ownership - if the entry already exists, reverts.\n    /// @param owner - owner of the relay (as configured off-chain)\n    function setRelayManagerOwner(address payable owner) external;\n\n    /// Only the owner can call this function. If the entry does not exist, reverts.\n    /// @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs\n    /// @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'\n    function stakeForRelayManager(address relayManager, uint256 unstakeDelay) external payable;\n\n    function unlockStake(address relayManager) external;\n\n    function withdrawStake(address relayManager) external;\n\n    function authorizeHubByOwner(address relayManager, address relayHub) external;\n\n    function authorizeHubByManager(address relayHub) external;\n\n    function unauthorizeHubByOwner(address relayManager, address relayHub) external;\n\n    function unauthorizeHubByManager(address relayHub) external;\n\n    function isRelayManagerStaked(address relayManager, address relayHub, uint256 minAmount, uint256 minUnstakeDelay)\n    external\n    view\n    returns (bool);\n\n    /// Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way.\n    /// @param relayManager - entry to penalize\n    /// @param beneficiary - address that receives half of the penalty amount\n    /// @param amount - amount to withdraw from stake\n    function penalizeRelayManager(address relayManager, address payable beneficiary, uint256 amount) external;\n\n    function getStakeInfo(address relayManager) external view returns (StakeInfo memory stakeInfo);\n\n    function maxUnstakeDelay() external view returns (uint256);\n\n    function versionSM() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@opengsn/contracts/src/utils/GsnUtils.sol": {
      "content": "/* solhint-disable no-inline-assembly */\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../utils/MinLibBytes.sol\";\n\nlibrary GsnUtils {\n\n    /**\n     * extract method sig from encoded function call\n     */\n    function getMethodSig(bytes memory msgData) internal pure returns (bytes4) {\n        return MinLibBytes.readBytes4(msgData, 0);\n    }\n\n    /**\n     * extract parameter from encoded-function block.\n     * see: https://solidity.readthedocs.io/en/develop/abi-spec.html#formal-specification-of-the-encoding\n     * the return value should be casted to the right type (uintXXX/bytesXXX/address/bool/enum)\n     */\n    function getParam(bytes memory msgData, uint index) internal pure returns (uint) {\n        return MinLibBytes.readUint256(msgData, 4 + index * 32);\n    }\n\n    //re-throw revert with the same revert data.\n    function revertWithData(bytes memory data) internal pure {\n        assembly {\n            revert(add(data,32), mload(data))\n        }\n    }\n\n}\n"
    },
    "@opengsn/contracts/src/utils/MinLibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// minimal bytes manipulation required by GSN\n// a minimal subset from 0x/LibBytes\n/* solhint-disable no-inline-assembly */\npragma solidity ^0.8.0;\n\nlibrary MinLibBytes {\n\n    //truncate the given parameter (in-place) if its length is above the given maximum length\n    // do nothing otherwise.\n    //NOTE: solidity warns unless the method is marked \"pure\", but it DOES modify its parameter.\n    function truncateInPlace(bytes memory data, uint256 maxlen) internal pure {\n        if (data.length > maxlen) {\n            assembly { mstore(data, maxlen) }\n        }\n    }\n\n    /// @dev Reads an address from a position in a byte array.\n    /// @param b Byte array containing an address.\n    /// @param index Index in byte array of address.\n    /// @return result address from byte array.\n    function readAddress(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (address result)\n    {\n        require (b.length >= index + 20, \"readAddress: data too short\");\n\n        // Add offset to index:\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n        index += 20;\n\n        // Read address from array memory\n        assembly {\n            // 1. Add index to address of bytes array\n            // 2. Load 32-byte word from memory\n            // 3. Apply 20-byte mask to obtain address\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n\n    function readBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        require(b.length >= index + 32, \"readBytes32: data too short\" );\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, add(index,32)))\n        }\n        return result;\n    }\n\n    /// @dev Reads a uint256 value from a position in a byte array.\n    /// @param b Byte array containing a uint256 value.\n    /// @param index Index in byte array of uint256 value.\n    /// @return result uint256 value from byte array.\n    function readUint256(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = uint256(readBytes32(b, index));\n        return result;\n    }\n\n    function readBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        require(b.length >= index + 4, \"readBytes4: data too short\");\n\n        // Read the bytes4 from array memory\n        assembly {\n            result := mload(add(b, add(index,32)))\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/paymasters/NaivePaymaster.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport '@opengsn/contracts/src/forwarder/IForwarder.sol';\nimport '@opengsn/contracts/src/BasePaymaster.sol';\n\nimport './OwlPaymasterBase.sol';\n\n/**\n * @dev This paymaster will approve transactions sent through a relay provider\n * by the target contracts that are updated in the 'targets' mapping. This\n * mapping maps an address to a boolean to indicate whether or not the address\n * can be approved or not for gasless transactions\n * https://docs.opengsn.org/tutorials/integration.html#creating_a_paymaster\n */\ncontract NaivePaymaster is OwlPaymasterBase {\n    //maps addresses to bool to indicate if they are approved for gasless transactions\n    mapping(address => bool) targets;\n\n    // allow the owner to set ourTarget\n    event TargetSet(address target);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev initializes a paymaster contract\n     * @param _admin admin of the paymaster\n     * @param _target the target address that should be approved for gasless transactions\n     * @param _forwarder address for the trusted forwarder for open GSN\n     */\n    function initialize(\n        address _admin,\n        address _target,\n        address _forwarder\n    ) external initializer {\n        __NaivePaymaster_init(_admin, _target, _forwarder);\n    }\n\n    function proxyinitialize(\n        address _admin,\n        address _target,\n        address _forwarder\n    ) external onlyInitializing {\n        __NaivePaymaster_init(_admin, _target, _forwarder);\n    }\n\n    function __NaivePaymaster_init(\n        address _admin,\n        address _target,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_admin, _forwarder);\n        __NaivePaymaster_init_unchained(_target);\n    }\n\n    function __NaivePaymaster_init_unchained(address _target) internal onlyInitializing {\n        targets[_target] = true;\n        emit TargetSet(_target);\n    }\n\n    /**\n     * @dev updates the mapping of target addresses to approve\n     * the passed in address\n     */\n    function setTarget(address target) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        targets[target] = true;\n        emit TargetSet(target);\n    }\n\n    /**\n     * @dev updates the mapping of target addresses to disapprove\n     * the passed in address\n     */\n    function removeTarget(address target) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        targets[target] = false;\n    }\n\n    event PreRelayed(uint256);\n    event PostRelayed(uint256);\n\n    /**\n     * @dev function that performs all access control. It verifies that\n     * the relay request passes in an address that has been set as a\n     * target address and is approved for a gasless transaction\n     */\n    function preRelayedCall(\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 maxPossibleGas\n    ) external virtual override returns (bytes memory context, bool) {\n        _verifyForwarder(relayRequest);\n        (signature, approvalData, maxPossibleGas);\n\n        require(targets[relayRequest.request.to] == true);\n        emit PreRelayed(block.timestamp);\n        return (abi.encode(block.timestamp), false);\n    }\n\n    /**\n     * @dev function that performs all bookkeeping after a function call\n     * has been made.\n     */\n    function postRelayedCall(\n        bytes calldata context,\n        bool success,\n        uint256 gasUseWithoutPost,\n        GsnTypes.RelayData calldata relayData\n    ) external virtual override {\n        (context, success, gasUseWithoutPost, relayData);\n        emit PostRelayed(abi.decode(context, (uint256)));\n    }\n\n    /**\n     * @dev function that is required for open GSN paymasters\n     */\n    function versionPaymaster() external view virtual override returns (string memory) {\n        return '2.0.3';\n    }\n}\n"
    },
    "contracts/testing/FactoryERC721.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\n\n/**\n * @dev **INTERNAL TOOL**\n * Used to factory ERC721 NFTs for unit testing\n */\ncontract FactoryERC721 is BaseRelayRecipient, ERC721 {\n    // ID Tracking\n    uint256 lastTokenId = 0;\n\n    /**\n     * @dev Creates ERC721 token\n     * @param nftName name used to identify nft\n     * @param nftSymbol ticker used to identify nft\n     */\n    constructor(string memory nftName, string memory nftSymbol) ERC721(nftName, nftSymbol) {}\n\n    /**\n     * @dev Creates and gives a token to whoever calls the method\n     * @param count number of tokens to generate and give\n     */\n    function mintTokens(uint256 count) public {\n        // Loop and assign tokens\n        for (uint256 i = 0; i < count; i++) {\n            _mint(_msgSender(), lastTokenId++);\n        }\n    }\n\n    /**\n     * @dev Mints a token and assigns it to `to`.\n     * doesn't require permissions.\n     * @param to add\n     * @param tokenId token\n     */\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @dev Mints a token and assigns it to `to`.\n     * doesn't require permissions.\n     * @param to add\n     * @param tokenId token\n     */\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    // Used for testing ONLY\n    function setTrustedForwarder(address forwarder) public {\n        _setTrustedForwarder(forwarder);\n    }\n\n    /**\n     * @notice the following 3 functions are all required for OpenGSN integration\n     */\n    function _msgSender() internal view override(BaseRelayRecipient, Context) returns (address sender) {\n        sender = BaseRelayRecipient._msgSender();\n    }\n\n    function _msgData() internal view override(BaseRelayRecipient, Context) returns (bytes calldata) {\n        return BaseRelayRecipient._msgData();\n    }\n\n    function versionRecipient() external pure override returns (string memory) {\n        return '2.2.6';\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/testing/FactoryERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\n\n/**\n * @dev **INTERNAL TOOL**\n * Used to factory ERC20 coins for unit testing\n */\ncontract FactoryERC20 is BaseRelayRecipient, ERC20 {\n    /**\n     * @dev Creates ERC20 token\n     * @param mintAmount how much should be minted and given to `msg.sender`.\n     * Pass `mintAmount=0` to create `1_000_000_000_000_000_000_000_000_000` coins.\n     * @param coinName name used to identify coin\n     * @param coinTicker ticker used to identify coin\n     */\n    constructor(\n        uint256 mintAmount,\n        string memory coinName,\n        string memory coinTicker\n    ) ERC20(coinName, coinTicker) {\n        if (mintAmount == 0) mintAmount = 1_000_000_000_000_000_000_000_000_000;\n        _mint(_msgSender(), mintAmount);\n    }\n\n    // Used for testing ONLY\n    function setTrustedForwarder(address forwarder) public {\n        _setTrustedForwarder(forwarder);\n    }\n\n    /**\n     * @notice the following 3 functions are all required for OpenGSN integration\n     */\n    function _msgSender() internal view override(BaseRelayRecipient, Context) returns (address sender) {\n        sender = BaseRelayRecipient._msgSender();\n    }\n\n    function _msgData() internal view override(BaseRelayRecipient, Context) returns (bytes calldata) {\n        return BaseRelayRecipient._msgData();\n    }\n\n    function versionRecipient() external pure override returns (string memory) {\n        return '2.2.6';\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/proxy/Beacon/UpgradeableBeaconInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport './IBeacon.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeaconInitializable is Initializable, IBeacon, OwnableUpgradeable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor() {}\n\n    function initialize(address _admin, address implementation_) public initializer {\n        _setImplementation(implementation_);\n\n        __Ownable_init();\n        _transferOwnership(_admin);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), 'UpgradeableBeacon: implementation is not a contract');\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "contracts/proxy/Beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "contracts/proxy/Beacon/BeaconProxyInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport './IBeacon.sol';\nimport '../ProxyUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxyInitializable is ProxyUpgradeable, ERC1967UpgradeUpgradeable, OwnableUpgradeable {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor() payable {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        address beacon,\n        bytes memory data\n    ) public payable initializer {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n\n        __Ownable_init();\n        _transferOwnership(_admin);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    function beacon() external view virtual returns (address) {\n        return _beacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    function setBeacon(address beacon, bytes memory data) external onlyOwner {\n        _setBeacon(beacon, data);\n    }\n}\n"
    },
    "contracts/proxy/ProxyUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract ProxyUpgradeable {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/plugins/Minter/builds/MinterSimple.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nimport '../MinterCore.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ncontract MinterSimple is MinterCore {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://MinterSimple/', version)));\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // Constructor\n    function initialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external initializer {\n        __MinterSimple_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external onlyInitializing {\n        __MinterSimple_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function __MinterSimple_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        __MinterCore_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function __MinterSimple_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function mint(address buyer, uint256 tokenId) public {\n        // Mint Operation\n        MinterCore._mintForFee(buyer, tokenId);\n    }\n\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function safeMint(address buyer, uint256 tokenId) public {\n        // Mint Operation\n        MinterCore._safeMintForFee(buyer, tokenId);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n\ninterface IMinterSimple is IERC165Upgradeable {\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function mint(uint256 tokenId) external;\n\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function safeMint(uint256 tokenId) external;\n}\n"
    },
    "contracts/plugins/Minter/builds/MinterRandom.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nimport '../MinterCore.sol';\nimport '../../../utils/SourceRandom.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ncontract MinterRandom is MinterCore {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://MinterRandom/', version)));\n\n    // Nonce\n    uint256 private _numMinted;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // Constructor\n    function initialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external initializer {\n        __MinterRandom_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external onlyInitializing {\n        __MinterRandom_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function __MinterRandom_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        __MinterCore_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function __MinterRandom_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function mint(address buyer) public {\n        // Generate tokenid\n        uint256 random = SourceRandom.getRandomDebug();\n        uint256 tokenId = SourceRandom.getSeededRandom(random, _numMinted++);\n\n        // Mint Operation\n        MinterCore._mintForFee(buyer, tokenId);\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function safeMint(address buyer) public {\n        // Generate tokenId\n        uint256 random = SourceRandom.getRandomDebug();\n        uint256 tokenId = SourceRandom.getSeededRandom(random, _numMinted++);\n\n        // Mint Operation\n        MinterCore._safeMintForFee(buyer, tokenId);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n\ninterface IMinterRandom is IERC165Upgradeable {\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function mint(address buyer) external;\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function safeMint(address buyer) external;\n}\n"
    },
    "contracts/plugins/Minter/builds/MinterAutoId.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\nimport '../MinterCore.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ncontract MinterAutoId is MinterCore {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://MinterAutoId/', version)));\n\n    // Track our next tokenId for each species\n    uint256 nextTokenId;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // Constructor\n    function initialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external initializer {\n        __MinterAutoId_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) external onlyInitializing {\n        __MinterAutoId_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n    }\n\n    function __MinterAutoId_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        __MinterCore_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n        __MinterAutoId_init_unchained();\n    }\n\n    function __MinterAutoId_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     * @return nextTokenId\n     */\n    function mint(address buyer) public virtual returns (uint256) {\n        MinterCore._mintForFee(buyer, nextTokenId++);\n        return nextTokenId;\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     * @return nextTokenId\n     */\n    function safeMint(address buyer) public virtual returns (uint256) {\n        MinterCore._safeMintForFee(buyer, nextTokenId++);\n        return nextTokenId;\n    }\n\n    /**\n     * @dev Used to set the starting nextTokenId value.\n     * Used to save situtations where someone mints directly\n     * and we get out of sync.\n     * @param nextTokenId_ next token id to be minted\n     */\n    function setNextTokenId(uint256 nextTokenId_) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        nextTokenId = nextTokenId_;\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ninterface IMinterAutoId is IERC165Upgradeable {\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function mint() external returns (uint256 nextTokenId);\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function safeMint() external returns (uint256 nextTokenId);\n\n    /**\n     * @dev Used to set the starting nextTokenId value.\n     * Used to save situtations where someone mints directly\n     */\n    function setNextTokenId(uint256 nextTokenId_) external;\n}\n"
    },
    "contracts/plugins/Minter/builds/MinterSimpleMerkle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\nimport './MinterAutoId.sol';\n\n/**\n * @dev Decentralized NFT Minter contract\n *\n */\ncontract MinterSimpleMerkle is MinterAutoId {\n    // Specification + ERC165\n    bytes4 private constant ERC165TAG =\n        bytes4(keccak256(abi.encodePacked('OWLProtocol://MinterSimpleMerkle/', version)));\n\n    // Merkle Root\n    bytes32 public merkleRoot;\n    string public uri;\n\n    event SetMerkleRoot(bytes32 merkleRoot);\n\n    // Constructor\n    function initialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        bytes32 _merkleRoot,\n        string calldata _uri,\n        address _forwarder\n    ) external initializer {\n        __MinterSimpleMerkle_init(\n            _admin,\n            _mintFeeToken,\n            _mintFeeAddress,\n            _mintFeeAmount,\n            _nftContractAddr,\n            _merkleRoot,\n            _uri,\n            _forwarder\n        );\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        bytes32 _merkleRoot,\n        string calldata _uri,\n        address _forwarder\n    ) external onlyInitializing {\n        __MinterSimpleMerkle_init(\n            _admin,\n            _mintFeeToken,\n            _mintFeeAddress,\n            _mintFeeAmount,\n            _nftContractAddr,\n            _merkleRoot,\n            _uri,\n            _forwarder\n        );\n    }\n\n    function __MinterSimpleMerkle_init(\n        address _admin,\n        address _mintFeeToken,\n        address _mintFeeAddress,\n        uint256 _mintFeeAmount,\n        address _nftContractAddr,\n        bytes32 _merkleRoot,\n        string calldata _uri,\n        address _forwarder\n    ) internal onlyInitializing {\n        __MinterAutoId_init(_admin, _mintFeeToken, _mintFeeAddress, _mintFeeAmount, _nftContractAddr, _forwarder);\n        __MinterSimpleMerkle_init_unchained(_merkleRoot, _uri);\n    }\n\n    function __MinterSimpleMerkle_init_unchained(bytes32 _merkleRoot, string calldata _uri) internal onlyInitializing {\n        merkleRoot = _merkleRoot;\n        uri = _uri;\n        emit SetMerkleRoot(merkleRoot);\n    }\n\n    // Disable MinterAutoId.mint()\n    function mint(address buyer) public pure override returns (uint256) {\n        (buyer);\n        revert('Must include merkleProof');\n    }\n\n    // Disable MinterAutoId.safeMint()\n    function safeMint(address buyer) public pure override returns (uint256) {\n        (buyer);\n        revert('Must include merkleProof');\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function mint(address buyer, bytes32[] calldata merkleProof) public {\n        require(_verifyMerkle(merkleProof), 'Not member of merkleTree!');\n        MinterAutoId.mint(buyer);\n    }\n\n    /**\n     * @dev Create a new type of species and define attributes.\n     */\n    function safeMint(address buyer, bytes32[] calldata merkleProof) public {\n        require(_verifyMerkle(merkleProof), 'Not member of merkleTree!');\n        MinterAutoId.mint(buyer);\n    }\n\n    function updateMerkleRoot(bytes32 _merkleRoot, string calldata _uri) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        merkleRoot = _merkleRoot;\n        uri = _uri;\n    }\n\n    function _verifyMerkle(bytes32[] calldata merkleProof) internal view returns (bool) {\n        bytes32 leaf = keccak256(abi.encode(msg.sender));\n        return MerkleProof.verify(merkleProof, merkleRoot, leaf);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n\ninterface IMinterSimpleMerkle is IERC165Upgradeable {\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function mint(\n        uint256 tokenId,\n        bytes32 merkleRoot,\n        bytes32[] calldata merkleProof\n    ) external;\n\n    /**\n     * @dev\n     * @param tokenId minted token id\n     */\n    function safeMint(\n        uint256 tokenId,\n        bytes32 merkleRoot,\n        bytes32[] calldata merkleProof\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/finance/Rent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\nimport '../assets/ERC721/ERC721OwlExpiring.sol';\n\n/**\n * @dev This Rent contract serves as a middleman and allows owners of NFTs to lock their assets in this\n * smart contract for a fixed epoch period. The contract then mints a new identical \"shadow\" NFT on a separate\n * smart contract. This \"shadow\" NFT can be sold and transferred like any other NFT when being rented. However,\n * after the epoch is finished, the \"shadow\" NFT is destroyed and the original NFT is returned to its original owner.\n * This contract can handle multiple rentals at a time and keeps track of rental instances using a rentId. This contract\n * is great for allowing owners of NFTs to earn income by renting out their assets and incentivizes renters to get a\n * chance to temporarily own a cool NFT.\n */\ncontract Rent is OwlBase, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://Rent/', version)));\n\n    /**********************\n             Types\n    **********************/\n    event Create(\n        uint256 indexed rentId,\n        address indexed owner,\n        address indexed renter,\n        uint256 nftId,\n        uint256 timePeriods,\n        uint256 pricePerPeriod,\n        uint256 expireTimePerPeriod\n    );\n    event Pay(uint256 indexed rentId, uint256 amountPaid);\n    event End(uint256 indexed rentId, uint256 amountPaid);\n    event Claim(address owner, uint256 amountClaimed);\n\n    //Rental Terms Struct - outlines all terms for a rental instance\n    struct RentalTerms {\n        uint256 nftId; //NFT ID used in minting the \"shadow\" NFT\n        address owner; //owner of original NFT\n        address renter; //renter that will temporarily own the \"shadow\" NFT\n        bool ended; //keeps track of rental duration\n        uint256 timePeriods; //number of rental periods to pay\n        uint256 pricePerPeriod; //price of each rental period\n        uint256 expireTimePerPeriod; //expire time per rental period which will dictate rent duration\n    }\n\n    address public acceptableToken; //ERC20 token that is acceptable for payment\n    address public shadowAddr; //address of where the shadow NFT is minted\n    address public contractAddr; //address of original NFT\n    uint256 numRentals; //number of Rentals made that is updated each time createRental is called\n\n    mapping(uint256 => RentalTerms) public rentTermsId; //maps a rentId to its specific Rental Terms Struct\n    mapping(uint256 => uint256) timePeriodsPaid; //maps the rental id to the number of time periods paid for that rental\n    mapping(address => uint256) balances; //maps an owner to the balances they can claim at any point\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializing the Rent contract\n     * @param _admin address of the launcher, which is this contract\n     * @param _acceptableToken accepted ERC20 token for payment\n     * @param _contractAddr contract address for original NFT\n     * @param _shadowAddr address where \"shadow\" NFT is minted\n     * @param _forwarder address for trusted forwarder for openGSN\n     */\n    function initialize(\n        address _admin,\n        address _acceptableToken,\n        address _contractAddr,\n        address _shadowAddr,\n        address _forwarder\n    ) external initializer {\n        __Rent_init(_admin, _acceptableToken, _contractAddr, _shadowAddr, _forwarder);\n    }\n\n    function proxyInitialize(\n        address _admin,\n        address _acceptableToken,\n        address _contractAddr,\n        address _shadowAddr,\n        address _forwarder\n    ) external onlyInitializing {\n        __Rent_init(_admin, _acceptableToken, _contractAddr, _shadowAddr, _forwarder);\n    }\n\n    function __Rent_init(\n        address _admin,\n        address _acceptableToken,\n        address _contractAddr,\n        address _shadowAddr,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_admin, _forwarder);\n\n        __Rent_init_unchained(_admin, _acceptableToken, _contractAddr, _shadowAddr);\n    }\n\n    function __Rent_init_unchained(\n        address _admin,\n        address _acceptableToken,\n        address _contractAddr,\n        address _shadowAddr\n    ) internal onlyInitializing {\n        acceptableToken = _acceptableToken;\n        contractAddr = _contractAddr;\n        shadowAddr = _shadowAddr;\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @dev Creates a single Rental based on the inputted Rental Term Struct that outlines all of the terms\n     * for that specific rental instance.\n     * Updates the various mappings and gives the Rental an ID.\n     * Increments the number of Rentals handled by this contract\n     * @param rentalTerm inputted rental term struct\n     */\n    function createRental(RentalTerms calldata rentalTerm) external {\n        rentTermsId[numRentals] = rentalTerm; //maps ID = numRentals to the passed in rentalTerm\n        timePeriodsPaid[numRentals] = 0; //initial number of rent periods paid for this Rental set to 0\n\n        //Transfers the NFT from the owner defined in the inputted rentalTerm to this contract address\n        IERC721Upgradeable(contractAddr).safeTransferFrom(rentalTerm.owner, address(this), rentalTerm.nftId);\n\n        emit Create(\n            numRentals,\n            rentalTerm.owner,\n            rentalTerm.renter,\n            rentalTerm.nftId,\n            rentalTerm.timePeriods,\n            rentalTerm.pricePerPeriod,\n            rentalTerm.expireTimePerPeriod\n        );\n        numRentals++; //increment rentId counter and the number of Rentals handled by this contract\n    }\n\n    /**\n     * @notice this function can only be called at the very start of a Rental process. It must be called\n     * to mint the shadow NFT\n     * @dev Starts the payment process for the Rental with rentId with it's first payment\n     * @param rentId inputted Rental ID that is used in the mapping to get the corresponding rental term struct\n     */\n    function startRent(uint256 rentId) external payable {\n        //startRent should be called by the renter\n        require(timePeriodsPaid[rentId] == 0, 'rent has already been started'); //makes sure no rent has been payed yet\n        RentalTerms memory r = rentTermsId[rentId]; //uses mapping to get the corresponding rental term struct based on rentId\n\n        payRent(rentId, 1); //calls the payRent method to pay rent for 1 time period only\n        ERC721OwlExpiring(shadowAddr).mint(r.renter, r.nftId, r.expireTimePerPeriod); //mints \"shadow\" NFT on the separate address\n\n        emit Pay(rentId, r.pricePerPeriod);\n    }\n\n    /**\n     * @dev function that allows a renter to pay rent for any number of time periods\n     * @param rentId inputted Rental ID that is used in the mapping to get the corresponding rental term struct\n     * @param timePeriodsToPay allows the renter to decide how many time periods they want to pay for at once\n     */\n    function payRent(uint256 rentId, uint256 timePeriodsToPay) public payable {\n        //payRent should be called by the renter\n        require(_msgSender() == rentTermsId[rentId].renter, 'you are not the renter and cannot pay rent');\n        require(!rentTermsId[rentId].ended, 'Rent has been terminated'); //rent cannot be terminated and rent duration must not be expired\n        require(\n            timePeriodsPaid[rentId] + timePeriodsToPay <= rentTermsId[rentId].timePeriods,\n            'you are trying to pay for extra periods!'\n        ); //renter must only be able to pay for at most the number of time periods that are defined in its corresponding rental terms struct\n\n        //updates the number of time periods already paid by the renter\n        timePeriodsPaid[rentId] += timePeriodsToPay;\n\n        //updates the balances that the owner can claim based on how many periods are paid and their price\n        RentalTerms memory r = rentTermsId[rentId];\n        balances[r.owner] += timePeriodsToPay * r.pricePerPeriod;\n\n        //transfers the price in ERC20 tokens owed by the renter to this contract\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            r.renter,\n            address(this),\n            timePeriodsToPay * r.pricePerPeriod\n        );\n\n        //updates the \"shadow\" address with the rent duration based on how much has been paid\n        //ensures that \"shadow\" NFT will not be destroyed yet because rent has been paid\n        ERC721OwlExpiring(shadowAddr).extendExpiry(rentId, timePeriodsToPay * r.expireTimePerPeriod);\n\n        emit Pay(rentId, timePeriodsToPay * r.pricePerPeriod);\n    }\n\n    /**\n     * @notice this function only updates the boolean for the rent status (ended vs not) and\n     * transfers the ownership of the NFT back to its owner. It does not give funds to the owner in ERC20 tokens\n     * @dev this function allows the owner to end the rental at any point in time\n     * @param rentalId inputted Rental ID that is used in the mapping to get the corresponding rental term struct\n     */\n    function endRental(uint256 rentalId) external payable {\n        //endRental can only be paid by the owner\n        require(_msgSender() == rentTermsId[rentalId].owner, 'you are not the owner and cannot end the rental');\n\n        rentTermsId[rentalId].ended = true;\n\n        //transfers ownership of the original NFT from this contract back to the respectful owner\n        IERC721Upgradeable(contractAddr).safeTransferFrom(\n            address(this),\n            rentTermsId[rentalId].owner,\n            rentTermsId[rentalId].nftId\n        );\n\n        emit End(rentalId, timePeriodsPaid[rentalId] * rentTermsId[rentalId].pricePerPeriod);\n    }\n\n    /**\n     * @dev this function enables the owner to claim the balances paid by the renter\n     */\n    function ownerClaim() external payable {\n        uint256 bal = balances[_msgSender()]; //temporarily holds all funds for the owner calling this function\n        balances[_msgSender()] = 0; //resets funds to 0 after owner claims balances\n\n        //transfers all funds to the owner calling this function in ERC20 tokens\n        IERC20Upgradeable(acceptableToken).transfer(_msgSender(), bal);\n\n        emit Claim(_msgSender(), bal);\n    }\n\n    /**\n    Getters\n    */\n\n    /**\n     * @dev gets a rental instance based on the inputted rentId\n     * @param rentId inputted rental term struct id\n     */\n    function getRental(uint256 rentId) external view returns (RentalTerms memory) {\n        //returns a rental based on the rentalId using the mapping\n        return rentTermsId[rentId];\n    }\n\n    /**\n     * @dev gets the number of rentals created on this contract\n     */\n    function getNumRentals() external view returns (uint256) {\n        return numRentals;\n    }\n\n    /**\n     * @dev gets the number of time periods paid by a renter for a specific Rental based on the inputted rentId\n     * @param rentalId inputted rental term struct id\n     */\n    function getTimePeriodsPaid(uint256 rentalId) external view returns (uint256) {\n        //returns number of time periods paid based on the rentalId using the mapping\n        return timePeriodsPaid[rentalId];\n    }\n\n    /**\n     * @dev gets how many time periods are left to pay for a specific Rental\n     * @param rentalId inputted rental term struct id\n     */\n    function getTimePeriodsLeftToPay(uint256 rentalId) external view returns (uint256) {\n        //returns number of time periods left to pay in a specific Rental\n        return rentTermsId[rentalId].timePeriods - timePeriodsPaid[rentalId];\n    }\n\n    /**\n     * @dev gets the total balance that is claimable by an owner\n     * @param owner owner of a Rental that can call this function to see how much they can claim\n     */\n    function getBalance(address owner) external view returns (uint256) {\n        //returns claimable funds for an owner\n        return balances[owner];\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/assets/ERC721/ERC721OwlExpiring.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\n\nimport './ERC721Owl.sol';\nimport 'hardhat/console.sol';\n\n/**\n * @dev This implementation is an extension of OwlProtocol's base {ERC721Owl}\n * contract. After a set amount of time determined at mint, the `tokenId` will\n * no longer belong to the minter. The update is not done through a transaction\n * but rather by overriding standaring {ERC721Owl} view function to return\n * `null` results after token expiry has passed.\n *\n * The default `mint(address,uint256)` is disabled in favor of a new signature\n * that allows setting of an expiry time.\n *\n * Initially, setting the expiry time is done by `MINTER_ROLE` during the minting\n * process however consequent updates to the expiry time (but before expiry has\n * taken place) must be done by `EXPIRY_ROLE`. After expiry, `tokenId` is able to\n * reminted by `MINTER_ROLE` but can also be extended by `EXPIRY_ROLE`\n */\ncontract ERC721OwlExpiring is ERC721Owl {\n    using StringsUpgradeable for uint256;\n\n    bytes32 private constant EXPIRY_ROLE = keccak256('EXPIRY_ROLE');\n    bytes4 private constant ERC165TAG =\n        bytes4(keccak256(abi.encodePacked('OWLProtocol://ERC721OwlExpiring/', VERSION)));\n\n    /**********************\n           Storage\n    **********************/\n\n    // Mapping from tokenId to block.timestamp in which tokenId expires\n    mapping(uint256 => uint256) internal expires;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /**\n     * @dev Initializes contract (replaces constructor in proxy pattern)\n     * @param _admin owner\n     * @param _name name\n     * @param _symbol symbol\n     * @param baseURI_ uri\n     * @param _forwarder trusted forwarder address for openGSN\n     */\n    function initialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external override initializer {\n        __ERC721OwlExpiring_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    /**\n     * @dev Initializes contract through beacon proxy (replaces constructor in\n     * proxy pattern)\n     */\n    function proxyInitialize(\n        address _admin,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata baseURI_,\n        address _forwarder\n    ) external override onlyInitializing {\n        __ERC721OwlExpiring_init(_admin, _name, _symbol, baseURI_, _forwarder);\n    }\n\n    function __ERC721OwlExpiring_init(\n        address _admin,\n        string memory _name,\n        string memory _symbol,\n        string memory baseURI_,\n        address _forwarder\n    ) internal onlyInitializing {\n        __ERC721Owl_init(_admin, _name, _symbol, baseURI_, _forwarder);\n        _grantRole(EXPIRY_ROLE, _admin);\n\n        __ERC721OwlExpiring_init_unchained();\n    }\n\n    function __ERC721OwlExpiring_init_unchained() internal onlyInitializing {}\n\n    /**********************\n          Interaction\n    **********************/\n\n    /**\n     * @notice Must have DEFAULT_ADMIN_ROLE\n     * @dev Grants EXPIRY_ROLE to `to`\n     * @param to address to\n     */\n    function grantExpiry(address to) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(EXPIRY_ROLE, to);\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        require(!_expired(tokenId), 'ERC721: owner query for nonexistent token');\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n        require(!_expired(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            'ERC721: approve caller is not owner nor approved for all'\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(!_expired(tokenId), 'ERC721: approved query for nonexistent token');\n        return ERC721Upgradeable.getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(!_expired(tokenId), 'ERC721: transfer query for nonexistent token');\n        ERC721Upgradeable.transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(!_expired(tokenId), 'ERC721: transfer query for nonexistent token');\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @notice function disabled\n     */\n    function mint(address, uint256) public pure override {\n        revert('ERC721OwlExpiring: function disabled');\n    }\n\n    /**\n     * @notice function disabled\n     */\n    function safeMint(address, uint256) public pure override {\n        revert('ERC721OwlExpiring: function disabled');\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows MINTER_ROLE to mint NFTs\n     * @param to address to\n     * @param tokenId tokenId value\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        uint256 expireTime\n    ) public onlyRole(MINTER_ROLE) {\n        // If token reaches expiry time, it is available to be reminted. This\n        // will be executed by performing a burn before a remint can take place\n        // without risk of revert\n        if (_expired(tokenId)) _burn(tokenId);\n        expires[tokenId] = expireTime + block.timestamp;\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows caller to mint NFTs (safeMint)\n     * @param to address to\n     * @param tokenId tokenId value\n     */\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        uint256 expireTime\n    ) public onlyRole(MINTER_ROLE) {\n        // If token reaches expiry time, it is available to be reminted. This\n        // will be executed by performing a burn before a remint can take place\n        // without risk of revert\n        if (_expired(tokenId)) _burn(tokenId);\n        expires[tokenId] = expireTime + block.timestamp;\n        _safeMint(to, tokenId);\n    }\n\n    /**\n     * @notice Must have EXPIRY_ROLE.\n     * @dev `expires` mapping is updated with new expire time\n     * @param tokenId to update\n     * @param extendAmount amount of time to extend by\n     */\n    function extendExpiry(uint256 tokenId, uint256 extendAmount) external onlyRole(EXPIRY_ROLE) {\n        expires[tokenId] += extendAmount;\n    }\n\n    /**\n     * @dev exposes read access to `expires` mapping\n     * @return expireTime block.timestamp of when tokenId expires\n     */\n    function getExpiry(uint256 tokenId) external view returns (uint256) {\n        return expires[tokenId];\n    }\n\n    /**\n     * @dev checks if tokenId is expired\n     * @return bool expired\n     */\n    function _expired(uint256 tokenId) internal view virtual returns (bool) {\n        return expires[tokenId] != 0 && expires[tokenId] < block.timestamp;\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721Owl) returns (bool) {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/finance/FixedPriceAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\nimport './AuctionLib.sol';\nimport 'hardhat/console.sol';\n\n/*\n * @dev This contract executes a simple fixed price, sell-buy auction.\n * The owner can set the price of the asset which will remain fixed throughout\n * the auction. If a buyer buys within the auction duration timeframe, then the asset\n * is transferred to the buyer and the price in ERC20 tokens is transferred from\n * the buyer to the seller. If no buyer buys within the auction duration, then the\n * owner must claim the asset back from the contract and no one is eligible to buy the asset\n * after the auction duration has passed.\n */\ncontract FixedPriceAuction is OwlBase, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG =\n        bytes4(keccak256(abi.encodePacked('OWLProtocol://FixedPriceAuction/', version)));\n\n    /**********************\n             Types\n    **********************/\n    event Start(uint256 startTime);\n    event Buy(address indexed buyer, uint256 indexed buyPrice);\n    event Claim(address indexed seller, address indexed contractAddr, uint256 tokenId);\n\n    AuctionLib.Asset asset;\n    address public acceptableToken;\n\n    address payable public seller;\n    address payable public saleFeeAddress;\n\n    uint256 public auctionDuration;\n    uint256 public price; //in \"eth\"\n    uint256 public startTime;\n    uint256 public saleFee; //integer percentage of sale set aside for owner commission\n\n    bool public isBought;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Create auction instance\n     * @param _seller address of seller for auction\n     * @param _asset struct containing information of the asset to be listed\n     * @param ERC20contractAddress address of ERC20 token accepted as payment\n     * @param _price price to start the auction\n     * @param _auctionDuration how long the auction should last\n     * @param _saleFee the percentage of the sale to be sent to the original owner as commission\n     * @param _saleFeeAddress the address to which the sale fee is sent\n     * @param _forwarder address for the trusted forwarder for open GSN integration\n     */\n    function initialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _price,\n        uint256 _auctionDuration,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external initializer {\n        __FixedPriceAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _price,\n            _auctionDuration,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function proxyInitialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _price,\n        uint256 _auctionDuration,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external onlyInitializing {\n        __FixedPriceAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _price,\n            _auctionDuration,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function __FixedPriceAuction_init(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _price,\n        uint256 _auctionDuration,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_seller, _forwarder);\n\n        __FixedPriceAuction_init_unchained(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _price,\n            _auctionDuration,\n            _saleFee,\n            _saleFeeAddress\n        );\n    }\n\n    function __FixedPriceAuction_init_unchained(\n        address payable _seller,\n        AuctionLib.Asset memory _asset,\n        address ERC20contractAddress,\n        uint256 _price,\n        uint256 _auctionDuration,\n        uint256 _saleFee,\n        address payable _saleFeeAddress\n    ) internal onlyInitializing {\n        require(_seller != _saleFeeAddress, 'FixedPriceAuction: seller cannot be the same as the owner!');\n        require(_saleFee <= 100, 'FixedPriceAuction: sale fee cannot be greater than 100 percent!');\n        asset = _asset;\n        startTime = block.timestamp;\n\n        acceptableToken = ERC20contractAddress;\n\n        seller = _seller;\n        auctionDuration = _auctionDuration;\n        price = _price;\n        isBought = false;\n        saleFee = _saleFee;\n        saleFeeAddress = _saleFeeAddress;\n\n        // Transferring ERC721 to contract\n        if (_asset.token == AuctionLib.TokenType.erc721) {\n            IERC721Upgradeable(_asset.contractAddr).transferFrom(seller, address(this), _asset.tokenId);\n        } else if (_asset.token == AuctionLib.TokenType.erc1155) {\n            // Transferring ERC1155\n            IERC1155Upgradeable(_asset.contractAddr).safeTransferFrom(\n                seller,\n                address(this),\n                _asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        } else revert('FixedPriceAuction: invalid asset token type');\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @dev function that allows a buyer to buy the asset at the fixed price\n     */\n    function buy() external {\n        //operations done in \"wei\"\n        require(block.timestamp < startTime + auctionDuration, 'FixedPriceAuction: ended');\n        require(!isBought, 'FixedPriceAuction: somebody has already bought this item!');\n\n        isBought = true;\n\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            _msgSender(),\n            saleFeeAddress,\n            (saleFee * price) / 100\n        );\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            _msgSender(),\n            seller,\n            price - (saleFee * price) / 100\n        );\n\n        // Transfer asset to buyer\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), _msgSender(), asset.tokenId);\n        else {\n            // Asset token type must be ERC1155 as no revert during initialization\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                address(this),\n                _msgSender(),\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        }\n\n        emit Buy(_msgSender(), price);\n    }\n\n    /**\n     * @notice must be the owner to call this function\n     * @dev allows the owner to reclaim their asset if no one buys\n     */\n    function claim() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        //owner withdraws asset if nobody buys\n        require(!isBought, 'FixedPriceAuction: cannot claim when the token has been sold already!');\n        require(\n            block.timestamp >= startTime + auctionDuration,\n            'FixedPriceAuction: cannot claim when auction is ongoing!'\n        );\n\n        //transfer asset back to owner\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), seller, asset.tokenId);\n        else {\n            // Asset token type must be ERC1155 as no revert during initialization\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                address(this),\n                seller,\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        }\n\n        emit Claim(seller, asset.contractAddr, asset.tokenId);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/finance/AuctionLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Basic auction structures used through auction contracts.\n *\n */\nlibrary AuctionLib {\n    enum TokenType {\n        erc721,\n        erc1155\n    }\n\n    struct Asset {\n        TokenType token;\n        address contractAddr;\n        uint256 tokenId;\n    }\n}\n"
    },
    "contracts/finance/EnglishAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\nimport './AuctionLib.sol';\n\n/**\n * @dev This contract is a standard English Auction smart contract that allows\n * bidders to keep bidding until the highest bidder wins the asset. In an\n * English Auction, the owner defines the starting price and bidders can make\n * bids that are higher than the current price.* The auction duration is defined\n * by the bids being made and if they are made within the resetTime.\n * Theoretically, the auction can go on forever if higher bids continue to be\n * made within the resetTime period.* Once the ending time is passed, the\n * auction finishes and the NFT is transferred to the highest bidder.\n */\ncontract EnglishAuction is OwlBase, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://EnglishAuction/', version)));\n\n    /**********************\n             Types\n    **********************/\n    event Start(uint256 startTime);\n    event Bid(address indexed sender, uint256 amount);\n    event Withdraw(address indexed bidder, uint256 amount);\n\n    AuctionLib.Asset public asset;\n    address public acceptableToken;\n\n    address payable public seller;\n    address payable public saleFeeAddress;\n    bool public ownerClaimed;\n    bool public winnerClaimed;\n\n    uint256 public endAt;\n    uint256 public auctionDuration;\n    uint256 public startPrice;\n    uint256 public resetTime; //number of seconds the auction is reset to after a bid within this time\n    uint256 public saleFee;\n\n    address public highestBidder;\n    mapping(address => uint256) public bids;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Create English Auction instance\n     * @param _seller address of seller for auction\n     * @param _asset struct containing information of the asset to be listed\n     * @param ERC20contractAddress address of ERC20 token accepted as payment\n     * @param _startPrice start bid on nft\n     * @param _auctionDuration duration of auction (in seconds)\n     * @param _resetTime time at which the auction resets when a bid is made within this time frame (in seconds)\n     * @param _saleFee the percentage of the sale to be sent to the original owner as commission\n     * @param _saleFeeAddress the address to which the sale fee is sent\n     * @param _forwarder the address for the Trusted Forwarder for Open GSN integration\n     */\n    function initialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _auctionDuration,\n        uint256 _resetTime,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external initializer {\n        __EnglishAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _auctionDuration,\n            _resetTime,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function proxyInitialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _auctionDuration,\n        uint256 _resetTime,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external onlyInitializing {\n        __EnglishAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _auctionDuration,\n            _resetTime,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function __EnglishAuction_init(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _auctionDuration,\n        uint256 _resetTime,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_seller, _forwarder);\n\n        __EnglishAuction_init_unchained(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _auctionDuration,\n            _resetTime,\n            _saleFee,\n            _saleFeeAddress\n        );\n    }\n\n    function __EnglishAuction_init_unchained(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _auctionDuration,\n        uint256 _resetTime,\n        uint256 _saleFee,\n        address payable _saleFeeAddress\n    ) internal onlyInitializing {\n        require(_saleFee <= 100, 'EnglishAuction: saleFee cannot be above 100 percent!');\n        asset = _asset;\n\n        acceptableToken = ERC20contractAddress;\n\n        seller = _seller;\n        auctionDuration = _auctionDuration;\n        startPrice = _startPrice;\n        resetTime = _resetTime;\n        saleFee = _saleFee;\n        saleFeeAddress = _saleFeeAddress;\n\n        // Transferring ERC721\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).transferFrom(seller, address(this), asset.tokenId);\n        else if (asset.token == AuctionLib.TokenType.erc1155)\n            // Transferring ERC1155\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                seller,\n                address(this),\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        else revert();\n\n        endAt = block.timestamp + _auctionDuration * 1 seconds;\n    }\n\n    /**********************\n         Interaction\n    **********************/\n    /**\n     * @dev Allow a user to place a bid that must be higher than the highest bid\n     * @param amount to bid by the bidder\n     */\n    function bid(uint256 amount) external {\n        require(block.timestamp < endAt, 'EnglishAuction: ended');\n        require(amount > bids[highestBidder], 'EnglishAuction: value <= highest');\n\n        highestBidder = _msgSender();\n        uint256 currBid = bids[_msgSender()];\n        bids[_msgSender()] += amount - bids[_msgSender()];\n\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            _msgSender(),\n            address(this),\n            amount - currBid\n        );\n\n        // if bid is made with < reset time remaining on the auction , then add to endAt\n        if (endAt - block.timestamp < resetTime) endAt = (block.timestamp + resetTime) * 1 seconds;\n\n        emit Bid(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Highest bidder cannot withdraw\n     * @dev Allows a user to withdraw their bid.\n     */\n    function withdraw() external {\n        // Added from parameter as above\n        require(_msgSender() != highestBidder, 'EnglishAuction: the highest bidder cannot withdraw!');\n\n        uint256 bal = bids[_msgSender()];\n        bids[_msgSender()] = 0;\n\n        IERC20Upgradeable(acceptableToken).transfer(_msgSender(), bal);\n\n        emit Withdraw(_msgSender(), bal);\n    }\n\n    /**\n     * @dev Allows owner to claim bid.\n     * The seller must call to transfer the ERC20 to themselves\n     */\n    function ownerClaim() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(block.timestamp >= endAt, 'EnglishAuction: not ended');\n        require(!ownerClaimed, 'EnglishAuction: owner has already claimed');\n\n        ownerClaimed = true;\n        if (highestBidder != address(0)) {\n            IERC20Upgradeable(acceptableToken).transfer(saleFeeAddress, (saleFee * bids[highestBidder]) / 100);\n\n            IERC20Upgradeable(acceptableToken).transfer(\n                seller,\n                bids[highestBidder] - (saleFee * bids[highestBidder]) / 100\n            );\n        } else {\n            if (asset.token == AuctionLib.TokenType.erc721)\n                IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), seller, asset.tokenId);\n            else {\n                // Asset token type is 1155 as initialization did not revert\n                IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                    address(this),\n                    seller,\n                    asset.tokenId,\n                    1,\n                    new bytes(0)\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Allows auction winner to claim the asset they won and transfers ownership\n     */\n    function winnerClaim() external {\n        require(block.timestamp >= endAt, 'EnglishAuction: not ended');\n        require(!winnerClaimed, 'EnglishAuction: winner has already claimed');\n        require(_msgSender() == highestBidder, 'EnglishAuction: you are not the winner, you cannot claim!'); //highestBidder at end is the winning address\n\n        winnerClaimed = true;\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), highestBidder, asset.tokenId);\n        else {\n            // Asset token type is 1155 as initialization did not revert\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                address(this),\n                highestBidder,\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        }\n    }\n\n    /**********************\n            Getters\n    **********************/\n\n    /**\n     * @dev Returns the current highest bid\n     */\n    function getCurrentBid() external view returns (uint256) {\n        //show the current price\n        return bids[highestBidder];\n    }\n\n    /**\n     * @dev Returns the remaining time in the auction\n     */\n    function getRemainingTime() external view returns (uint256) {\n        if (block.timestamp >= endAt) return 0;\n        return endAt - block.timestamp; //in seconds\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/finance/DutchAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\n\nimport '../OwlBase.sol';\n\nimport '../utils/FractionalExponents.sol';\nimport './AuctionLib.sol';\n\n/**\n * @dev This contract is a simple on-chain Dutch Auction with a pricing view function that\n * decreases over a set period of time. In a Dutch Auction, the seller defines a starting ceiling price\n * and an ending floor price that then decreases over time based on either a linear or nonlinear function.\n * If a bid is made at any point, the bid must match the current price. Once a bid is made, the auction ends\n * and the owner will receive the current price in which the bid was made in ERC20 tokens. The asset is then\n * transferred to the bidder.\n */\ncontract DutchAuction is OwlBase, ERC721HolderUpgradeable, ERC1155HolderUpgradeable, FractionalExponents {\n    // Specification + ERC165\n    string public constant version = 'v0.1';\n    bytes4 private constant ERC165TAG = bytes4(keccak256(abi.encodePacked('OWLProtocol://DutchAuction/', version)));\n\n    /**********************\n             Types\n    **********************/\n    event Start(uint256 startTime);\n    event Bid(address indexed sender, uint256 indexed amount);\n    event Claim(address indexed seller, address indexed contractAddr, uint256 tokenId);\n\n    AuctionLib.Asset public asset;\n    address public acceptableToken;\n\n    address payable public seller;\n    address payable public saleFeeAddress;\n\n    uint256 public auctionDuration;\n    uint256 public startPrice; //starting maximum price\n    uint256 public endPrice; //floor price\n    uint256 public startTime;\n    uint256 public saleFee;\n\n    bool public isNonLinear;\n    bool public isBought;\n\n    /**********************\n        Initialization\n    **********************/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Create auction instance\n     * @param _seller address of seller for auction\n     * @param _asset struct containing information of the asset to be listed\n     * @param ERC20contractAddress address of ERC20 token accepted as payment\n     * @param _startPrice highest starting price to start the auction\n     * @param _endPrice lowest price that seller is willing to accept\n     * @param _auctionDuration duration of auction (in seconds)\n     * @param _isNonLinear set true if the seller wants to set a nonlinear decrease in price\n     * @param _saleFee the percentage of the sale to be sent to the original owner as commission\n     * @param _saleFeeAddress the address to which the sale fee is sent\n     * @param _forwarder the address for the Trusted Forwarder for Open GSN integration\n     */\n    function initialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _endPrice,\n        uint256 _auctionDuration,\n        bool _isNonLinear,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external initializer {\n        __DutchAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _endPrice,\n            _auctionDuration,\n            _isNonLinear,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function proxyInitialize(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _endPrice,\n        uint256 _auctionDuration,\n        bool _isNonLinear,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) external onlyInitializing {\n        __DutchAuction_init(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _endPrice,\n            _auctionDuration,\n            _isNonLinear,\n            _saleFee,\n            _saleFeeAddress,\n            _forwarder\n        );\n    }\n\n    function __DutchAuction_init(\n        address payable _seller,\n        AuctionLib.Asset calldata _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _endPrice,\n        uint256 _auctionDuration,\n        bool _isNonLinear,\n        uint256 _saleFee,\n        address payable _saleFeeAddress,\n        address _forwarder\n    ) internal onlyInitializing {\n        __OwlBase_init(_seller, _forwarder);\n\n        __DutchAuction_init_unchained(\n            _seller,\n            _asset,\n            ERC20contractAddress,\n            _startPrice,\n            _endPrice,\n            _auctionDuration,\n            _isNonLinear,\n            _saleFee,\n            _saleFeeAddress\n        );\n    }\n\n    function __DutchAuction_init_unchained(\n        address payable _seller,\n        AuctionLib.Asset memory _asset,\n        address ERC20contractAddress,\n        uint256 _startPrice,\n        uint256 _endPrice,\n        uint256 _auctionDuration,\n        bool _isNonLinear,\n        uint256 _saleFee,\n        address payable _saleFeeAddress\n    ) internal onlyInitializing {\n        require(_startPrice > _endPrice, 'DutchAuction: start price must be greater than end price');\n        asset = _asset;\n\n        acceptableToken = ERC20contractAddress;\n\n        seller = _seller;\n        auctionDuration = _auctionDuration;\n        startPrice = _startPrice;\n        endPrice = _endPrice;\n        isNonLinear = _isNonLinear;\n        isBought = false;\n        saleFee = _saleFee;\n        saleFeeAddress = _saleFeeAddress;\n\n        //transferring ERC 721\n        if (_asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(_asset.contractAddr).transferFrom(seller, address(this), _asset.tokenId);\n        else if (_asset.token == AuctionLib.TokenType.erc1155)\n            //transferring ERC 1155\n            IERC1155Upgradeable(_asset.contractAddr).safeTransferFrom(\n                seller,\n                address(this),\n                _asset.tokenId,\n                1,\n                new bytes(0)\n            );\n        startTime = block.timestamp;\n    }\n\n    /**********************\n            Getters\n    **********************/\n\n    /**\n     * @dev Returns the current price of the asset based on the timestamp and type of function\n     * @return uint256 price of the asset\n     */\n    function getCurrentPrice() public view returns (uint256) {\n        //show the current price\n        if (block.timestamp >= startTime + auctionDuration) return 1e18 * endPrice;\n        if (isNonLinear) {\n            (uint256 result, uint8 precision) = (\n                power(startPrice - endPrice, 1, uint32(block.timestamp - startTime), uint32(auctionDuration))\n            );\n            uint256 exp = ((1e18 * result) / (2**precision));\n            int256 const = int256((1e18 * int256(startPrice - endPrice)) / (1 + int256(endPrice) - int256(startPrice)));\n\n            return uint256(((const * int256(exp)) / 1e18) - const + 1e18 * int256(startPrice));\n        }\n        return (1e18 *\n            startPrice -\n            (((1e18 * (block.timestamp - startTime)) / (auctionDuration)) * ((startPrice - endPrice))));\n    }\n\n    /**********************\n         Interaction\n    **********************/\n\n    /**\n     * @notice The required ERC20 tokens must be pre-approved before calling!\n     * @dev Allows a user to bid at the current price\n     */\n    function bid() external {\n        require(block.timestamp < startTime + auctionDuration, 'DutchAuction: ended');\n        require(!isBought, 'DutchAuction: somebody has already bought this item!');\n\n        uint256 bidPrice = getCurrentPrice();\n\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            _msgSender(),\n            saleFeeAddress,\n            (saleFee * bidPrice) / 100\n        );\n        SafeERC20Upgradeable.safeTransferFrom(\n            IERC20Upgradeable(acceptableToken),\n            _msgSender(),\n            seller,\n            bidPrice - (saleFee * bidPrice) / 100\n        );\n\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), _msgSender(), asset.tokenId);\n        else if (asset.token == AuctionLib.TokenType.erc1155)\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                address(this),\n                _msgSender(),\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n\n        isBought = true;\n\n        emit Bid(_msgSender(), bidPrice);\n    }\n\n    /**\n     * @dev Allows the owner to claim back the asset if nobody bids and auction expires\n     */\n    function claim() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        //owner withdraws asset if nobody bids\n        require(block.timestamp >= startTime + auctionDuration, 'DutchAuction: cannot claim when auction is ongoing!');\n\n        if (asset.token == AuctionLib.TokenType.erc721)\n            IERC721Upgradeable(asset.contractAddr).safeTransferFrom(address(this), seller, asset.tokenId);\n        else if (asset.token == AuctionLib.TokenType.erc1155)\n            IERC1155Upgradeable(asset.contractAddr).safeTransferFrom(\n                address(this),\n                seller,\n                asset.tokenId,\n                1,\n                new bytes(0)\n            );\n\n        emit Claim(seller, asset.contractAddr, asset.tokenId);\n    }\n\n    /**\n     * @dev ERC165 Support\n     * @param interfaceId hash of the interface testing for\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC1155ReceiverUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == ERC165TAG || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/utils/FractionalExponents.sol": {
      "content": "/**\n * FractionalExponents\n * Copied and modified from:\n *  https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/converter/BancorFormula.sol#L289\n * Redistributed Under Apache License 2.0:\n *  https://github.com/bancorprotocol/contracts/blob/master/LICENSE\n * Provided as an answer to:\n *  https://ethereum.stackexchange.com/questions/50527/is-there-any-efficient-way-to-compute-the-exponentiation-of-an-fractional-base-a\n */\n\npragma solidity ^0.8.0;\n\ncontract FractionalExponents  {\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_WEIGHT = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    uint256[128] private maxExpArray;\n    function BancorFormula() public {\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n\n\n    /**\n        General Description:\n            Determine a value of precision.\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n            Return the result along with the precision used.\n        Detailed Description:\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n            The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n            The larger \"precision\" is, the more accurately this value represents the real value.\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n            This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n    */\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8) {\n        assert(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = _baseN * FIXED_1 / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        }\n        else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        }\n        else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n        Compute log(x / FIXED_1) * FIXED_1.\n        This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n    */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\n    }\n\n    /**\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\n    */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        }\n        else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x)\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x)\n            return hi;\n        if (maxExpArray[lo] >= _x)\n            return lo;\n\n        assert(false);\n        return 0;\n    }\n\n    /**\n        This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n    */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision; res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n        Return log(x / FIXED_1) * FIXED_1\n        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n    */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;}\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;}\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;}\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;}\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;}\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;}\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;}\n        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;}\n\n        z = y = x - FIXED_1;\n        w = y * y / FIXED_1;\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1;\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;\n\n        return res;\n    }\n\n    /**\n        Return e ^ (x / FIXED_1) * FIXED_1\n        Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n    */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000;\n        z = z * y / FIXED_1; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = z * y / FIXED_1; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = z * y / FIXED_1; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = z * y / FIXED_1; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = z * y / FIXED_1; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = z * y / FIXED_1; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = z * y / FIXED_1; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = z * y / FIXED_1; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = z * y / FIXED_1; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = z * y / FIXED_1; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = z * y / FIXED_1; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = z * y / FIXED_1; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = z * y / FIXED_1; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = z * y / FIXED_1; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = z * y / FIXED_1; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = z * y / FIXED_1; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = z * y / FIXED_1; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776;\n        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4;\n        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\n        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\n        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea;\n        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d;\n        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11;\n\n        return res;\n    }\n}\n"
    },
    "contracts/testing/FactoryERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport '@opengsn/contracts/src/BaseRelayRecipient.sol';\n\n/**\n * @dev **INTERNAL TOOL**\n * Used to factory ERC721 NFTs for unit testing\n */\ncontract FactoryERC1155 is BaseRelayRecipient, ERC1155 {\n    // ID Tracking\n    uint256 lastTokenId = 0;\n    uint256 constant defaultTokenMint = 10;\n\n    /**\n     * @dev Creates ERC721 token\n     * @param uri associate\n     */\n    constructor(string memory uri, uint256[] memory initialMint) ERC1155(uri) {\n        if (initialMint.length == 0) {\n            initialMint = new uint256[](defaultTokenMint);\n            for (uint256 i = 0; i < defaultTokenMint; i++) initialMint[i] = 100;\n        }\n        mintTokens(initialMint);\n    }\n\n    /**\n     * @dev Creates and gives a token to whoever calls the method\n     * @param amounts array of token amounts to mint for each tokenID\n     */\n    function mintTokens(uint256[] memory amounts) public {\n        // Loop and assign tokens\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _mint(_msgSender(), lastTokenId++, amounts[i], new bytes(0));\n        }\n    }\n\n    /**\n     * @dev Mints a token and assigns it to `to`.\n     * doesn't require permissions.\n     * @param to add\n     * @param tokenId token\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) public {\n        _mint(to, tokenId, amount, new bytes(0));\n    }\n\n    /**\n     * @notice Must have MINTER_ROLE\n     * @dev Allows caller to mint NFTs (safeMint)\n     * @param to address to\n     * @param ids id values\n     * @param amounts to mint\n     * @param data for hooks\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public {\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    // Used for testing ONLY\n    function setTrustedForwarder(address forwarder) public {\n        _setTrustedForwarder(forwarder);\n    }\n\n    /**\n     * @notice the following 3 functions are all required for OpenGSN integration\n     */\n    function _msgSender() internal view override(BaseRelayRecipient, Context) returns (address sender) {\n        sender = BaseRelayRecipient._msgSender();\n    }\n\n    function _msgData() internal view override(BaseRelayRecipient, Context) returns (bytes calldata) {\n        return BaseRelayRecipient._msgData();\n    }\n\n    function versionRecipient() external pure override returns (string memory) {\n        return '2.2.6';\n    }\n}\n"
    },
    "contracts/paymasters/AcceptEverythingPaymaster.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@opengsn/contracts/src/BasePaymaster.sol';\nimport './OwlPaymasterBase.sol';\n\n// accept everything.\n// this paymaster accepts any request.\n//\n// NOTE: Do NOT use this contract on a mainnet: it accepts anything, so anyone can \"grief\" it and drain its account\n\ncontract AcceptEverythingPaymaster is OwlPaymasterBase {\n    function versionPaymaster() external view virtual override returns (string memory) {\n        return '2.2.0+opengsn.accepteverything.ipaymaster';\n    }\n\n    function preRelayedCall(\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 maxPossibleGas\n    ) external virtual override returns (bytes memory context, bool revertOnRecipientRevert) {\n        (relayRequest, signature, approvalData, maxPossibleGas);\n        return ('', false);\n    }\n\n    function postRelayedCall(\n        bytes calldata context,\n        bool success,\n        uint256 gasUseWithoutPost,\n        GsnTypes.RelayData calldata relayData\n    ) external virtual override {\n        (context, success, gasUseWithoutPost, relayData);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}