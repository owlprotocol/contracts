//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "./MinterLib.sol";
import "./IMintableERC721.sol";
import "../Utils/SourceRandom.sol";

/**
 * @dev Decentralized NFT Minter contract
 *
 */
contract Minter {

    // Data Storage
    using Counters for Counters.Counter;
    Counters.Counter private speciesIds;

    mapping (uint256 => MinterLib.Species) internal species;

    // Modifiers
    modifier speciesOwner(uint256 speciesId) {
        // also tests for existence with below require
        require(msg.sender == species[speciesId].owner, "You are not the owner!");
        _;
    }

    // Events
    event CreateSpecies(
        uint256 speciesId,
        address contractAddr,
        address indexed owner,
        address mintFeeToken,
        address mintFeeAddress,
        uint256 mintFeeAmount,
        MinterLib.SpeciesFeature[] speciesFeatures
    );

    // todo - swap DNA w/ uint256
    event RegisterSpecimen(
        uint256 indexed speciesId,
        uint256 tokenId,
        MinterLib.SpecimenFeature[] specimenFeatures
    );

    // Functions

    /**
     * @dev Create a new type of species and define attributes.
     * @param contractAddress address of associated NFT
     * @param speciesFeatures list of features objects generated by species
     */
    function createSpecies(
        address contractAddress,
        address mintFeeToken,
        address mintFeeAddress,
        uint256 mintFeeAmount,
        MinterLib.SpeciesFeature[] calldata speciesFeatures
    ) public {
        require(contractAddress != address(0));

        // Species Counter
        speciesIds.increment();

        // Save our pointer
        MinterLib.Species storage s = species[speciesIds.current()];
        s.contractAddr = contractAddress;
        s.owner = msg.sender;
        s.mintFeeToken = mintFeeToken;
        s.mintFeeAddress = mintFeeAddress;
        s.mintFeeAmount = mintFeeAmount;

        for (uint i = 0; i < speciesFeatures.length; i++) {
            require(speciesFeatures[i].minValue < speciesFeatures[i].maxValue);
            s.speciesFeatures.push(speciesFeatures[i]);
        }

        emit CreateSpecies(
            speciesIds.current(),
            contractAddress,
            msg.sender,
            mintFeeToken,
            mintFeeAddress,
            mintFeeAmount,
            speciesFeatures
        );
    }

    /**
     * @dev Register an existing NFT and generate DNA for it. Requires speciesOwner permissions!
     * @param speciesId species to register NFT to
     * @param tokenId ID of associated NFT
     */
    function registerSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public speciesOwner(speciesId) {
        // Create entropy / register specimen
        uint256 randomSeed = SourceRandom.getRandomDebug();
        _registerSpecimen(speciesId, tokenId, randomSeed);
    }

    /**
     * @dev Register minted Specimens into Minter and generate DNA!
     * @param speciesId species to register NFT to
     * @param tokenId ID of associated NFT
     */
    function registerMintedSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public {
        // Don't allow regeneration for DNA
        require(
            species[speciesId].specimen[tokenId].dna == 0,
            "This species already has DNA!"
        );
        // Only allow NFT owners to generate their DNA
        require(
            IERC721(species[speciesId].contractAddr).ownerOf(tokenId) == msg.sender,
            "You are not the owner of this NFT!"
        );

        // Create entropy / register specimen
        uint256 randomSeed = SourceRandom.getRandomDebug();
        _registerSpecimen(speciesId, tokenId, randomSeed);
    }

    /**
     * @dev Mint a new specimen and generate DNA for it. Costs an ERC20 fee.
     * @param speciesId id of species to mint specimen for
     */
    function mintSpecimen(
        uint256 speciesId
    ) public {
        // Species pointer
        MinterLib.Species storage s = species[speciesId];

        // Transfer ERC20
        SafeERC20.safeTransferFrom(
            IERC20(s.mintFeeToken),
            msg.sender,
            s.mintFeeAddress,
            s.mintFeeAmount
        );

        // Mint our NFT / transfer to `msg.sender`
        IMintableERC721(species[speciesId].contractAddr).mint(msg.sender);
     }

    /*
     * @dev Register an existing NFT and generate DNA for it (internal function).
     * @param speciesId species to register NFT to
     * @param tokenId ID of associated NFT
     **/
    function _registerSpecimen(
        uint256 speciesId,
        uint256 tokenId,
        uint256 randomSeed
    ) internal {
        // Setup pointer
        MinterLib.Specimen storage s = species[speciesId].specimen[tokenId];

        require(s.createdBlock == 0, "Specimen already exists!");

        // Set date of birth
        s.createdBlock = uint64(block.number);
        // Generate DNA
        _generateRandomDNA(speciesId, randomSeed, s);

        emit RegisterSpecimen(
            speciesId,
            tokenId,
            s.features
        );
    }

    /**
     * @dev Returns features created for a species
     * @param speciesId species identifier
     */
    function getSpecies(
        uint256 speciesId
    ) public view returns (
        address contractAddr,
        address owner,
        MinterLib.SpeciesFeature[] memory features
    ) {
        MinterLib.Species storage s = species[speciesId];
        return (
            s.contractAddr,
            s.owner,
            s.speciesFeatures
        );
    }

    /**
     * @dev Returns features created for a species
     * @param speciesId species identifier
     * @param tokenId NFT identifier
     */
    function getSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public view returns (
        uint256 createdBlock,
        MinterLib.SpecimenFeature[] memory features
    ) {
        MinterLib.Specimen storage s = species[speciesId].specimen[tokenId];
        return (
            s.createdBlock,
            s.features
        );
    }

    /**
     * @dev Generate random DNA for a new specimen and write it to object.
     * @param speciesId species to use for DNA generation
     * @param randomSeed random seed used in DNA generation
     * @param specimen pointer to existing specimen.
     */
    function _generateRandomDNA(
        uint256 speciesId,
        uint256 randomSeed,
        MinterLib.Specimen storage specimen
    ) private {
        MinterLib.Species storage s = species[speciesId];

        MinterLib.SpecimenFeature memory feature;
        uint256 randomNonce = 0;
        uint256 random;

        for (uint i = 0; i < s.speciesFeatures.length; i++) {

            // Get a random value from seed + nonce
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));

            // random % (max-min + 1)
            feature.featureValue = uint128(random % uint256(s.speciesFeatures[i].maxValue - s.speciesFeatures[i].minValue + 1));

            // We need another truly-random value for recessive/dominant.
            // If we were to use the same, certain trait values would correlate.
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));
            feature.featureType = MinterLib.FeatureType(random % 2);

            // Assign values to specimen (via pointer)
            specimen.features.push(feature);
        }
    }

}
