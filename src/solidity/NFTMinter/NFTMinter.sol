//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Counters.sol";

import "./NFTMinterLibrary.sol";
import "../Utils/SourceRandom.sol";

/**
 * @dev Decentralized NFT Minter contract
 *
 */
contract NFTMinter {

    // Data Storage
    using Counters for Counters.Counter;
    Counters.Counter private speciesIds;

    mapping (uint256 => NFTMinterLibrary.Species) public species;

    // Modifiers

    modifier speciesOwner(uint256 speciesId) {
        // also tests for existence with below require
        // also allows contract to call itself
        require(msg.sender == species[speciesId].owner, "You are not the owner!");
        _;
    }

    // Events
    event CreateSpecies(
        uint256 speciesId,
        bytes32 name,
        address contractAddr,
        address owner,
        NFTMinterLibrary.SpeciesFeature[] speciesFeatures
    );

    event RegisterSpecimen(
        uint256 speciesId,
        uint256 tokenId,
        NFTMinterLibrary.SpecimenFeature[] specimenFeatures
    );

    // Functions

    /// @dev Create a new type of species and define attributes.
    /// @param name URI to identify created species
    /// @param contractAddress address of associated NFT
    /// @param speciesFeatures list of features objects generated by species
    function createSpecies(
        bytes32 name,
        address contractAddress,
        NFTMinterLibrary.SpeciesFeature[] calldata speciesFeatures
    ) public {
        require(contractAddress != address(0));

        // Species Counter
        speciesIds.increment();

        // Save our pointer
        NFTMinterLibrary.Species storage s = species[speciesIds.current()];
        s.name = name;
        s.contractAddr = contractAddress;
        s.owner = msg.sender;

        for (uint i = 0; i < speciesFeatures.length; i++) {
            require(speciesFeatures[i].minValue < speciesFeatures[i].maxValue);
            s.speciesFeatures.push(speciesFeatures[i]);
        }

        emit CreateSpecies(
            speciesIds.current(),
            name,
            contractAddress,
            msg.sender,
            speciesFeatures
        );
    }

    /// @dev Register an existing NFT and generate DNA for it. Requires speciesOwner permissions!
    /// @param speciesId species to register NFT to
    /// @param tokenId ID of associated NFT
    function registerSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public speciesOwner(speciesId) { _registerSpecimen(speciesId, tokenId); }

    /// @dev Register an existing NFT and generate DNA for it (internal function).
    /// @param speciesId species to register NFT to
    /// @param tokenId ID of associated NFT
    function _registerSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) internal {
        // Setup pointer
        NFTMinterLibrary.Specimen storage s = species[speciesId].specimen[tokenId];

        require(s.createdBlock == 0, "Specimen already exists!");

        // Create entropy
        uint256 randomSeed = SourceRandom.getRandomDebug();

        // Call for specimen generation
        _generateSpecimen(speciesId, randomSeed, s);

        emit RegisterSpecimen(
            speciesId,
            tokenId,
            s.features
        );
    }


    /// @dev Returns features created for a species
    /// @param speciesId species identifier
    function getSpecies(
        uint256 speciesId
    ) public view returns (
        bytes32 name,
        address contractAddr,
        address owner,
        NFTMinterLibrary.SpeciesFeature[] memory features
    ) {
        NFTMinterLibrary.Species storage s = species[speciesId];
        return (
            s.name,
            s.contractAddr,
            s.owner,
            s.speciesFeatures
        );
    }

    /// @dev Returns features created for a species
    /// @param speciesId species identifier
    /// @param tokenId NFT identifier
    function getSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public view returns (
        uint256 createdBlock,
        NFTMinterLibrary.SpecimenFeature[] memory features
    ) {
        NFTMinterLibrary.Specimen storage s = species[speciesId].specimen[tokenId];
        return (
            s.createdBlock,
            s.features
        );
    }

    /// @dev Process to generates and stores a new specimen.
    /// Simple now, could be more complex later. Also allows
    /// batch functions to hook onto this.
    /// @param speciesId species to register NFT to
    /// @param randomSeed randomly generated seed to use for DNA generation
    /// @param specimen unique token to identify
    function _generateSpecimen(
        uint256 speciesId,
        uint256 randomSeed,
        NFTMinterLibrary.Specimen storage specimen
    ) internal {
        // Set date of birth
        specimen.createdBlock = block.number;
        // Generate DNA
        _generateRandomDNA(speciesId, randomSeed, specimen);
    }

    /// @dev Generate random DNA for a new specimen and write it to object.
    /// @param speciesId species to use for DNA generation
    /// @param randomSeed random seed used in DNA generation
    /// @param specimen pointer to existing specimen.
    function _generateRandomDNA(
        uint256 speciesId,
        uint256 randomSeed,
        NFTMinterLibrary.Specimen storage specimen
    ) private {

        NFTMinterLibrary.Species storage s = species[speciesId];

        NFTMinterLibrary.SpecimenFeature memory feature;
        uint256 randomNonce = 0;
        uint256 random;

        for (uint i = 0; i < s.speciesFeatures.length; i++) {

            // Get a random value from seed + nonce
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));

            // random % (max-min + 1)
            feature.featureValue = uint128(random % (s.speciesFeatures[i].maxValue - s.speciesFeatures[i].minValue + 1));

            // We need another truly-random value for recessive/dominant.
            // If we were to use the same, certain trait values would correlate.
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));
            feature.featureType = NFTMinterLibrary.FeatureType(random % 2);

            // Assign values to specimen (via pointer)
            specimen.features.push(feature);
        }
    }

}
