//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Counters.sol";

import "./NFTMinterLibrary.sol";
import "../Utils/SourceRandom.sol";

/**
 * @dev Decentralized NFT Minter contract
 *
 */
contract NFTMinter {

    // Data Storage
    using Counters for Counters.Counter;
    Counters.Counter private speciesIds;

    mapping (uint256 => NFTMinterLibrary.Species) public species;

    // Modifiers

    modifier speciesOwner(uint256 speciesId) {
        // also tests for existence with below require
        // also allows contract to call itself
        require(msg.sender == species[speciesId].owner || msg.sender == address(this), "You are not the owner!");
        _;
    }

    // Events
    event CreateSpecies(
        uint256 speciesId,
        bytes32 name,
        address contractAddr,
        address owner,
        NFTMinterLibrary.SpeciesFeature[] speciesFeatures
    );

    event RegisterSpecimen(
        uint256 speciesId,
        uint256 tokenId,
        NFTMinterLibrary.SpecimenFeature[] specimenFeatures
    );

    // Functions

    /// @dev Create a new type of species and define attributes.
    /// @param name URI to identify created species
    /// @param contractAddress address of associated NFT
    /// @param speciesFeatures list of features objects generated by species
    function createSpecies(
        bytes32 name,
        address contractAddress,
        NFTMinterLibrary.SpeciesFeature[] calldata speciesFeatures
    ) public {
        require(contractAddress != address(0));

        // Species Counter
        speciesIds.increment();

        // Save our pointer
        NFTMinterLibrary.Species storage s = species[speciesIds.current()];
        s.name = name;
        s.contractAddr = contractAddress;
        s.owner = msg.sender;

        for (uint i = 0; i < speciesFeatures.length; i++) {
            require(speciesFeatures[i].minValue < speciesFeatures[i].maxValue);
            s.speciesFeatures.push(speciesFeatures[i]);
        }

        emit CreateSpecies(
            speciesIds.current(),
            name,
            contractAddress,
            msg.sender,
            speciesFeatures
        );
    }

    /// @dev Register an existing NFT and generate DNA for it.
    /// @param speciesId species to register NFT to
    /// @param tokenId ID of associated NFT
    function registerSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public speciesOwner(speciesId) {
        NFTMinterLibrary.Specimen storage s = species[speciesId].specimen[tokenId];

        require(s.createdBlock == 0, "Specimen already exists!");

        s.createdBlock = block.number;
        // Generate DNA for species (uses specimen pointer)
        _generateRandomDNA(speciesId, s);

        emit RegisterSpecimen(
            speciesId,
            tokenId,
            s.features
        );

    }


    /// @dev Returns features created for a species
    /// @param speciesId species identifier
    function getSpecies(
        uint256 speciesId
    ) public view returns (
        bytes32 name,
        address contractAddr,
        address owner,
        NFTMinterLibrary.SpeciesFeature[] memory features
    ) {
        NFTMinterLibrary.Species storage s = species[speciesId];
        return (
            s.name,
            s.contractAddr,
            s.owner,
            s.speciesFeatures
        );
    }

    /// @dev Returns features created for a species
    /// @param speciesId species identifier
    /// @param tokenId NFT identifier
    function getSpecimen(
        uint256 speciesId,
        uint256 tokenId
    ) public view returns (
        uint256 createdBlock,
        NFTMinterLibrary.SpecimenFeature[] memory features
    ) {
        NFTMinterLibrary.Specimen storage s = species[speciesId].specimen[tokenId];
        return (
            s.createdBlock,
            s.features
        );
    }

    /// @dev Generate random DNA for a new specimen and write it to object.
    /// @param speciesId species to use for DNA generation
    /// @param specimen pointer to existing specimen.
    function _generateRandomDNA(
        uint256 speciesId,
        NFTMinterLibrary.Specimen storage specimen
    ) private {

        NFTMinterLibrary.Species storage s = species[speciesId];

        NFTMinterLibrary.SpecimenFeature memory feature;
        uint256 randomSeed = SourceRandom.getRandomDebug();
        uint256 randomNonce = 0;
        uint256 random;

        for (uint i = 0; i < s.speciesFeatures.length; i++) {

            // Get a random value from seed + nonce
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));

            // random % (max-min + 1)
            feature.featureValue = uint128(random % (s.speciesFeatures[i].maxValue - s.speciesFeatures[i].minValue + 1));

            // We need another truly-random value for recessive/dominant.
            // If we were to use the same, certain trait values would correlate.
            random = SourceRandom.getSeededRandom(abi.encode(randomSeed, randomNonce++));
            feature.featureType = NFTMinterLibrary.FeatureType(random % 2);

            // Assign values to specimen (via pointer)
            specimen.features.push(feature);
        }
    }

}
