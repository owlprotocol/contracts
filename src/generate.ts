import { writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';
import path from 'path';
import { sync as globSync } from 'glob';
import { configObj } from '../configObj';

function generateEthers(contract: string, name: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ContractFactory } from 'ethers';
import { abi, bytecode } from '../../${contract}.json';

export default new ContractFactory(abi, bytecode);`;
    writeFileSync(path.resolve(outputDir, `${name}.ts`), template);
}

function generateTruffle(contract: string, name: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ${name}Contract as ContractInterface } from '../../typechain/${name}';
import Artifact from '../../${contract}.json';

const Contract = require('@truffle/contract');
export default Contract(Artifact) as ContractInterface;`;
    writeFileSync(path.resolve(outputDir, `${name}.ts`), template);
}

function generateWeb3(contract: string, name: string, outputDir: string) {
    const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import Web3 from 'web3';
import { ${contract} as ContractInterface } from '../types/web3/${contract}';
import { abi, bytecode } from '../abi/${contract}.json';

const ContractFactory = (web3: Web3, address: string | undefined) =>
    new web3.eth.Contract(abi as any, address, {
        data: bytecode,
        from: web3.eth.defaultAccount ?? undefined,
    }) as unknown as ContractInterface;
export default ContractFactory;`;

    writeFileSync(path.resolve(outputDir, `${name}.ts`), template);
}

function generateIndex(names: string[], outputDir: string) {
    let indexFile = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
`;
    names.forEach((name) => {
        indexFile = `${indexFile}\nimport ${name} from './${name}'`;
    });

    indexFile = `${indexFile}\nexport { ${names} };`;
    writeFileSync(path.resolve(outputDir, 'index.ts'), indexFile);
}

function generate(contracts: string[], outputDir: string) {
    const names = contracts.map((x) => {
        const arr = x.split('/');
        return arr[arr.length - 1];
    });

    let generateTarget: (contract: string, name: string, outputDir: string) => void;

    if (!configObj.typechain || !configObj.typechain.target)
        throw new Error('Hardhat typechain target configuration required');

    const { target } = configObj.typechain;
    if (target.includes('ethers')) generateTarget = generateEthers;
    else if (target.includes('truffle')) generateTarget = generateTruffle;
    else if (target.includes('web3')) generateTarget = generateWeb3;

    contracts.forEach((contract, i) => {
        generateTarget(contract, names[i], outputDir);
    });

    generateIndex(names, outputDir);
}

function main() {
    //Abi index.ts
    //Do NOT index ABIs generated from imported libraries
    const contractsSolidityNames = globSync('contracts/**/*.sol').map((x) => path.basename(x).replace('.sol', ''));

    //could also use hre.artifacts.getArtifactPaths()
    const contractsAbiPaths = globSync('artifacts/**/*.json').map((x) => x.replace('.json', ''));
    const contractNamesSet = new Set(contractsSolidityNames);

    const indexAbiPaths = contractsAbiPaths.filter((abi) => {
        const arr = abi.split('/');
        if (arr.length === 0) return;

        return contractNamesSet.has(arr[arr.length - 1]);
    });

    // //Generate factories
    // //Deployable contracts only
    const deployableAbiPaths = indexAbiPaths.filter((x) => {
        const { abi, bytecode } = JSON.parse(readFileSync(`${x}.json`, 'utf-8'));
        return abi && abi.length > 0 && bytecode && bytecode.length > 2; //Bytecode != 0x
    });

    const outputDir = { ethers: 'factory/ethers', truffle: 'factory/truffle', web3: 'factory/web3' };
    if (!existsSync('factory')) mkdirSync('factory');
    if (!existsSync(outputDir.ethers)) mkdirSync(outputDir.ethers);
    if (!existsSync(outputDir.truffle)) mkdirSync(outputDir.truffle);
    if (!existsSync(outputDir.web3)) mkdirSync(outputDir.web3);

    let currDir = '';

    if (!configObj.typechain || !configObj.typechain.target)
        throw new Error('Hardhat typechain target configuration required');

    const { target } = configObj.typechain;
    if (target.includes('ethers')) currDir = outputDir.ethers;
    else if (target.includes('truffle')) currDir = outputDir.truffle;
    else if (target.includes('web3')) currDir = outputDir.web3;
    generate(deployableAbiPaths, currDir);
}

if (typeof require !== 'undefined' && require.main === module) {
    main();
}
