"use strict";(self.webpackChunkowlprotocol_contracts_docs=self.webpackChunkowlprotocol_contracts_docs||[]).push([[3099],{7522:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(9901);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,x=d["".concat(p,".").concat(m)]||d[m]||s[m]||i;return n?a.createElement(x,o(o({ref:t},u),{},{components:n})):a.createElement(x,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1211:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>s});var a=n(2875),r=n(358),i=(n(9901),n(7522)),o=["components"],l={},p=void 0,c={unversionedId:"contract-docs/FractionalExponents",id:"contract-docs/FractionalExponents",title:"FractionalExponents",description:"FractionalExponents",source:"@site/docs/contract-docs/FractionalExponents.md",sourceDirName:"contract-docs",slug:"/contract-docs/FractionalExponents",permalink:"/contracts/docs/contract-docs/FractionalExponents",draft:!1,editUrl:"https://github.com/owlprotocol/contracts/docs/contract-docs/FractionalExponents.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FixedPriceAuction",permalink:"/contracts/docs/contract-docs/FixedPriceAuction"},next:{title:"IBeacon",permalink:"/contracts/docs/contract-docs/IBeacon"}},u={},s=[{value:"FractionalExponents",id:"fractionalexponents",level:2},{value:"ONE",id:"one",level:3},{value:"MAX_WEIGHT",id:"max_weight",level:3},{value:"MIN_PRECISION",id:"min_precision",level:3},{value:"MAX_PRECISION",id:"max_precision",level:3},{value:"FIXED_1",id:"fixed_1",level:3},{value:"FIXED_2",id:"fixed_2",level:3},{value:"MAX_NUM",id:"max_num",level:3},{value:"LN2_NUMERATOR",id:"ln2_numerator",level:3},{value:"LN2_DENOMINATOR",id:"ln2_denominator",level:3},{value:"OPT_LOG_MAX_VAL",id:"opt_log_max_val",level:3},{value:"OPT_EXP_MAX_VAL",id:"opt_exp_max_val",level:3},{value:"maxExpArray",id:"maxexparray",level:3},{value:"BancorFormula",id:"bancorformula",level:3},{value:"power",id:"power",level:3},{value:"generalLog",id:"generallog",level:3},{value:"floorLog2",id:"floorlog2",level:3},{value:"findPositionInMaxExpArray",id:"findpositioninmaxexparray",level:3},{value:"generalExp",id:"generalexp",level:3},{value:"optimalLog",id:"optimallog",level:3},{value:"optimalExp",id:"optimalexp",level:3}],d={toc:s};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"fractionalexponents"},"FractionalExponents"),(0,i.kt)("h3",{id:"one"},"ONE"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 ONE\n")),(0,i.kt)("h3",{id:"max_weight"},"MAX_WEIGHT"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint32 MAX_WEIGHT\n")),(0,i.kt)("h3",{id:"min_precision"},"MIN_PRECISION"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint8 MIN_PRECISION\n")),(0,i.kt)("h3",{id:"max_precision"},"MAX_PRECISION"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint8 MAX_PRECISION\n")),(0,i.kt)("h3",{id:"fixed_1"},"FIXED_1"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 FIXED_1\n")),(0,i.kt)("h3",{id:"fixed_2"},"FIXED_2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 FIXED_2\n")),(0,i.kt)("h3",{id:"max_num"},"MAX_NUM"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 MAX_NUM\n")),(0,i.kt)("h3",{id:"ln2_numerator"},"LN2_NUMERATOR"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 LN2_NUMERATOR\n")),(0,i.kt)("h3",{id:"ln2_denominator"},"LN2_DENOMINATOR"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 LN2_DENOMINATOR\n")),(0,i.kt)("h3",{id:"opt_log_max_val"},"OPT_LOG_MAX_VAL"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 OPT_LOG_MAX_VAL\n")),(0,i.kt)("h3",{id:"opt_exp_max_val"},"OPT_EXP_MAX_VAL"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 OPT_EXP_MAX_VAL\n")),(0,i.kt)("h3",{id:"maxexparray"},"maxExpArray"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256[128] maxExpArray\n")),(0,i.kt)("h3",{id:"bancorformula"},"BancorFormula"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function BancorFormula() public\n")),(0,i.kt)("h3",{id:"power"},"power"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8)\n")),(0,i.kt)("p",null,"General Description:\nDetermine a value of precision.\nCalculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) ",(0,i.kt)("em",{parentName:"p"},' 2 ^ precision.\nReturn the result along with the precision used.\nDetailed Description:\nInstead of calculating "base ^ exp", we calculate "e ^ (log(base) '),' exp)".\nThe value of "log(base)" is represented with an integer slightly smaller than "log(base) * 2 ^ precision".\nThe larger "precision" is, the more accurately this value represents the real value.\nHowever, the larger "precision" is, the more bits are required in order to store this value.\nAnd the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").\nThis maximum exponent depends on the "precision" used, and it is given by "maxExpArray',"[precision]",' >> (MAX_PRECISION - precision)".\nHence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\nThis allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\nThis functions assumes that "_expN < 2 ^ 256 / log(MAX_NUM - 1)", otherwise the multiplication should be replaced with a "safeMul".'),(0,i.kt)("h3",{id:"generallog"},"generalLog"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function generalLog(uint256 x) internal pure returns (uint256)\n")),(0,i.kt)("p",null,'Compute log(x / FIXED_1) * FIXED_1.\nThis functions assumes that "x >= FIXED_1", because the output would be negative otherwise.'),(0,i.kt)("h3",{id:"floorlog2"},"floorLog2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function floorLog2(uint256 _n) internal pure returns (uint8)\n")),(0,i.kt)("p",null,"Compute the largest integer smaller than or equal to the binary logarithm of the input."),(0,i.kt)("h3",{id:"findpositioninmaxexparray"},"findPositionInMaxExpArray"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8)\n")),(0,i.kt)("p",null,'The global "maxExpArray" is sorted in descending order, and therefore the following statements are equivalent:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    - This function finds the position of [the smallest value in "maxExpArray" larger than or equal to "x"]\n    - This function finds the highest position of [a value in "maxExpArray" larger than or equal to "x"]\n')),(0,i.kt)("h3",{id:"generalexp"},"generalExp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256)\n")),(0,i.kt)("p",null,'This function can be auto-generated by the script \'PrintFunctionGeneralExp.py\'.\nIt approximates "e ^ x" via maclaurin summation: "(x^0)/0! + (x^1)/1! + ... + (x^n)/n!".\nIt returns "e ^ (x / 2 ^ precision) * 2 ^ precision", that is, the result is upshifted for accuracy.\nThe global "maxExpArray" maps each "precision" to "((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1".\nThe maximum permitted value for "x" is therefore given by "maxExpArray',"[precision]",' >> (MAX_PRECISION - precision)".'),(0,i.kt)("h3",{id:"optimallog"},"optimalLog"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function optimalLog(uint256 x) internal pure returns (uint256)\n")),(0,i.kt)("p",null,"Return log(x / FIXED_1) * FIXED_1\nInput range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1"),(0,i.kt)("h3",{id:"optimalexp"},"optimalExp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function optimalExp(uint256 x) internal pure returns (uint256)\n")),(0,i.kt)("p",null,"Return e ^ (x / FIXED_1) * FIXED_1\nInput range: 0 <= x <= OPT_EXP_MAX_VAL - 1"))}m.isMDXComponent=!0}}]);