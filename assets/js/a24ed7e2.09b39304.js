"use strict";(self.webpackChunkowlprotocol_contracts_docs=self.webpackChunkowlprotocol_contracts_docs||[]).push([[419],{7522:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(9901);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(a),m=r,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return a?n.createElement(k,o(o({ref:t},d),{},{components:a})):n.createElement(k,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},6437:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>u});var n=a(4514),r=a(9994),l=(a(9901),a(7522)),o=["components"],i={},s=void 0,p={unversionedId:"contract-docs/RentableERC721Upgradeable",id:"contract-docs/RentableERC721Upgradeable",title:"RentableERC721Upgradeable",description:"RentableERC721Upgradeable",source:"@site/docs/contract-docs/RentableERC721Upgradeable.md",sourceDirName:"contract-docs",slug:"/contract-docs/RentableERC721Upgradeable",permalink:"/contracts/docs/contract-docs/RentableERC721Upgradeable",editUrl:"https://github.com/owlprotocol/contracts/docs/contract-docs/RentableERC721Upgradeable.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"RentableERC721Owl",permalink:"/contracts/docs/contract-docs/RentableERC721Owl"},next:{title:"UpgradeableBeaconInitializable",permalink:"/contracts/docs/contract-docs/UpgradeableBeaconInitializable"}},d={},u=[{value:"RentableERC721Upgradeable",id:"rentableerc721upgradeable",level:2},{value:"_name",id:"_name",level:3},{value:"_symbol",id:"_symbol",level:3},{value:"_owners",id:"_owners",level:3},{value:"_balances",id:"_balances",level:3},{value:"_tokenApprovals",id:"_tokenapprovals",level:3},{value:"_operatorApprovals",id:"_operatorapprovals",level:3},{value:"rentalExpires",id:"rentalexpires",level:3},{value:"__RentableERC721Upgradeable_init",id:"__rentableerc721upgradeable_init",level:3},{value:"__RentableERC721Upgradeable_init_unchained",id:"__rentableerc721upgradeable_init_unchained",level:3},{value:"supportsInterface",id:"supportsinterface",level:3},{value:"balanceOf",id:"balanceof",level:3},{value:"ownerOf",id:"ownerof",level:3},{value:"name",id:"name",level:3},{value:"symbol",id:"symbol",level:3},{value:"tokenURI",id:"tokenuri",level:3},{value:"_baseURI",id:"_baseuri",level:3},{value:"approve",id:"approve",level:3},{value:"getApproved",id:"getapproved",level:3},{value:"setApprovalForAll",id:"setapprovalforall",level:3},{value:"isApprovedForAll",id:"isapprovedforall",level:3},{value:"transferFrom",id:"transferfrom",level:3},{value:"safeTransferFrom",id:"safetransferfrom",level:3},{value:"safeTransferFrom",id:"safetransferfrom-1",level:3},{value:"_safeTransfer",id:"_safetransfer",level:3},{value:"_exists",id:"_exists",level:3},{value:"_isApprovedOrOwner",id:"_isapprovedorowner",level:3},{value:"_safeMint",id:"_safemint",level:3},{value:"_safeMint",id:"_safemint-1",level:3},{value:"_mint",id:"_mint",level:3},{value:"_burn",id:"_burn",level:3},{value:"_transfer",id:"_transfer",level:3},{value:"_approve",id:"_approve",level:3},{value:"_setApprovalForAll",id:"_setapprovalforall",level:3},{value:"_checkOnERC721Received",id:"_checkonerc721received",level:3},{value:"_beforeTokenTransfer",id:"_beforetokentransfer",level:3},{value:"_afterTokenTransfer",id:"_aftertokentransfer",level:3},{value:"__gap",id:"__gap",level:3}],c={toc:u};function m(e){var t=e.components,a=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"rentableerc721upgradeable"},"RentableERC721Upgradeable"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Implementation of ",(0,l.kt)("a",{parentName:"em",href:"https://eips.ethereum.org/EIPS/eip-721%5BERC721%5D"},"https://eips.ethereum.org/EIPS/eip-721[ERC721]")," Non-Fungible Token Standard, including\nthe Metadata extension, but not including the Enumerable extension, which is available separately as\n{ERC721Enumerable}.")),(0,l.kt)("h3",{id:"_name"},"_name"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"string _name\n")),(0,l.kt)("h3",{id:"_symbol"},"_symbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"string _symbol\n")),(0,l.kt)("h3",{id:"_owners"},"_owners"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(uint256 &#x3D;&gt; address) _owners\n")),(0,l.kt)("h3",{id:"_balances"},"_balances"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address &#x3D;&gt; uint256) _balances\n")),(0,l.kt)("h3",{id:"_tokenapprovals"},"_tokenApprovals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(uint256 &#x3D;&gt; address) _tokenApprovals\n")),(0,l.kt)("h3",{id:"_operatorapprovals"},"_operatorApprovals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; bool)) _operatorApprovals\n")),(0,l.kt)("h3",{id:"rentalexpires"},"rentalExpires"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(uint256 &#x3D;&gt; uint256) rentalExpires\n")),(0,l.kt)("h3",{id:"__rentableerc721upgradeable_init"},"__RentableERC721Upgradeable_init"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function __RentableERC721Upgradeable_init(string name_, string symbol_) internal\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Initializes the contract by setting a ","`","name","`"," and a ","`","symbol","`"," to the token collection.")),(0,l.kt)("h3",{id:"__rentableerc721upgradeable_init_unchained"},"__RentableERC721Upgradeable_init_unchained"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function __RentableERC721Upgradeable_init_unchained(string name_, string symbol_) internal\n")),(0,l.kt)("h3",{id:"supportsinterface"},"supportsInterface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC165-supportsInterface}.")),(0,l.kt)("h3",{id:"balanceof"},"balanceOf"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function balanceOf(address owner) public view virtual returns (uint256)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-balanceOf}.")),(0,l.kt)("h3",{id:"ownerof"},"ownerOf"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function ownerOf(uint256 tokenId) public view virtual returns (address)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-ownerOf}.")),(0,l.kt)("h3",{id:"name"},"name"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function name() public view virtual returns (string)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721Metadata-name}.")),(0,l.kt)("h3",{id:"symbol"},"symbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function symbol() public view virtual returns (string)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721Metadata-symbol}.")),(0,l.kt)("h3",{id:"tokenuri"},"tokenURI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function tokenURI(uint256 tokenId) public view virtual returns (string)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721Metadata-tokenURI}.")),(0,l.kt)("h3",{id:"_baseuri"},"_baseURI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _baseURI() internal view virtual returns (string)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Base URI for computing {tokenURI}. If set, the resulting URI for each\ntoken will be the concatenation of the ","`","baseURI","`"," and the ","`","tokenId","`",". Empty\nby default, can be overridden in child contracts.")),(0,l.kt)("h3",{id:"approve"},"approve"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function approve(address to, uint256 tokenId) public virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-approve}.")),(0,l.kt)("h3",{id:"getapproved"},"getApproved"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getApproved(uint256 tokenId) public view virtual returns (address)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-getApproved}.")),(0,l.kt)("h3",{id:"setapprovalforall"},"setApprovalForAll"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setApprovalForAll(address operator, bool approved) public virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-setApprovalForAll}.")),(0,l.kt)("h3",{id:"isapprovedforall"},"isApprovedForAll"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function isApprovedForAll(address owner, address operator) public view virtual returns (bool)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-isApprovedForAll}.")),(0,l.kt)("h3",{id:"transferfrom"},"transferFrom"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function transferFrom(address from, address to, uint256 tokenId) public virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-transferFrom}.")),(0,l.kt)("h3",{id:"safetransferfrom"},"safeTransferFrom"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function safeTransferFrom(address from, address to, uint256 tokenId) public virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-safeTransferFrom}.")),(0,l.kt)("h3",{id:"safetransferfrom-1"},"safeTransferFrom"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data) public virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"See {IERC721-safeTransferFrom}.")),(0,l.kt)("h3",{id:"_safetransfer"},"_safeTransfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _safeTransfer(address from, address to, uint256 tokenId, bytes _data) internal virtual\n")),(0,l.kt)("p",null,"_Safely transfers ","`","tokenId","`"," token from ","`","from","`"," to ","`","to","`",", checking first that contract recipients\nare aware of the ERC721 protocol to prevent tokens from being forever locked."),(0,l.kt)("p",null,"`","_data","`"," is additional data, it has no specified format and it is sent in call to ","`","to","`","."),(0,l.kt)("p",null,"This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\nimplement alternative mechanisms to perform token transfer, such as signature-based."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","from","`"," cannot be the zero address."),(0,l.kt)("li",{parentName:"ul"},"`","to","`"," cannot be the zero address."),(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," token must exist and be owned by ","`","from","`","."),(0,l.kt)("li",{parentName:"ul"},"If ","`","to","`"," refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.")),(0,l.kt)("p",null,"Emits a {Transfer} event._"),(0,l.kt)("h3",{id:"_exists"},"_exists"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _exists(uint256 tokenId) internal view virtual returns (bool)\n")),(0,l.kt)("p",null,"_Returns whether ","`","tokenId","`"," exists."),(0,l.kt)("p",null,"Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}."),(0,l.kt)("p",null,"Tokens start existing when they are minted (","`",(0,l.kt)("em",{parentName:"p"},"mint","`","),\nand stop existing when they are burned (","`","_burn","`",").")),(0,l.kt)("h3",{id:"_isapprovedorowner"},"_isApprovedOrOwner"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool)\n")),(0,l.kt)("p",null,"_Returns whether ","`","spender","`"," is allowed to manage ","`","tokenId","`","."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," must exist._")),(0,l.kt)("h3",{id:"_safemint"},"_safeMint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _safeMint(address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Safely mints ","`","tokenId","`"," and transfers it to ","`","to","`","."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," must not exist."),(0,l.kt)("li",{parentName:"ul"},"If ","`","to","`"," refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.")),(0,l.kt)("p",null,"Emits a {Transfer} event._"),(0,l.kt)("h3",{id:"_safemint-1"},"_safeMint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _safeMint(address to, uint256 tokenId, bytes _data) internal virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Same as {xref-ERC721-_safeMint-address-uint256-}","[`","_safeMint","`]",", with an additional ","`","data","`"," parameter which is\nforwarded in {IERC721Receiver-onERC721Received} to contract recipients.")),(0,l.kt)("h3",{id:"_mint"},"_mint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _mint(address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Mints ","`","tokenId","`"," and transfers it to ","`","to","`","."),(0,l.kt)("p",null,"WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible"),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," must not exist."),(0,l.kt)("li",{parentName:"ul"},"`","to","`"," cannot be the zero address.")),(0,l.kt)("p",null,"Emits a {Transfer} event._"),(0,l.kt)("h3",{id:"_burn"},"_burn"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _burn(uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Destroys ","`","tokenId","`",".\nThe approval is cleared when the token is burned."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," must exist.")),(0,l.kt)("p",null,"Emits a {Transfer} event._"),(0,l.kt)("h3",{id:"_transfer"},"_transfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _transfer(address from, address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Transfers ","`","tokenId","`"," from ","`","from","`"," to ","`","to","`",".\nAs opposed to {transferFrom}, this imposes no restrictions on msg.sender."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"`","to","`"," cannot be the zero address."),(0,l.kt)("li",{parentName:"ul"},"`","tokenId","`"," token must be owned by ","`","from","`",".")),(0,l.kt)("p",null,"Emits a {Transfer} event._"),(0,l.kt)("h3",{id:"_approve"},"_approve"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _approve(address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Approve ","`","to","`"," to operate on ","`","tokenId","`"),(0,l.kt)("p",null,"Emits a {Approval} event._"),(0,l.kt)("h3",{id:"_setapprovalforall"},"_setApprovalForAll"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _setApprovalForAll(address owner, address operator, bool approved) internal virtual\n")),(0,l.kt)("p",null,"_Approve ","`","operator","`"," to operate on all of ","`","owner","`"," tokens"),(0,l.kt)("p",null,"Emits a {ApprovalForAll} event._"),(0,l.kt)("h3",{id:"_checkonerc721received"},"_checkOnERC721Received"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes _data) private returns (bool)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\nThe call is not executed if the target address is not a contract.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"from"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"address representing the previous owner of the given token ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"to"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"target address that will receive the tokens")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256 ID of the token to be transferred")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_data"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes optional data to send along with the call")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool whether the call correctly returned the expected magic value")))),(0,l.kt)("h3",{id:"_beforetokentransfer"},"_beforeTokenTransfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Hook that is called before any token transfer. This includes minting\nand burning."),(0,l.kt)("p",null,"Calling conditions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"When ","`","from","`"," and ","`","to","`"," are both non-zero, ","`","`","from","`","`","'","s ","`","tokenId","`"," will be\ntransferred to ","`","to","`","."),(0,l.kt)("li",{parentName:"ul"},"When ","`","from","`"," is zero, ","`","tokenId","`"," will be minted for ","`","to","`","."),(0,l.kt)("li",{parentName:"ul"},"When ","`","to","`"," is zero, ","`","`","from","`","`","'","s ","`","tokenId","`"," will be burned."),(0,l.kt)("li",{parentName:"ul"},"`","from","`"," and ","`","to","`"," are never both zero.")),(0,l.kt)("p",null,"To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks","[Using Hooks]","._"),(0,l.kt)("h3",{id:"_aftertokentransfer"},"_afterTokenTransfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual\n")),(0,l.kt)("p",null,"_Hook that is called after any transfer of tokens. This includes\nminting and burning."),(0,l.kt)("p",null,"Calling conditions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when ","`","from","`"," and ","`","to","`"," are both non-zero."),(0,l.kt)("li",{parentName:"ul"},"`","from","`"," and ","`","to","`"," are never both zero.")),(0,l.kt)("p",null,"To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks","[Using Hooks]","._"),(0,l.kt)("h3",{id:"__gap"},"__gap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256[44] __gap\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"This empty reserved space is put in place to allow future versions to add new\nvariables without shifting down storage in the inheritance chain.\nSee ",(0,l.kt)("a",{parentName:"em",href:"https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps"},"https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps"))))}m.isMDXComponent=!0}}]);