"use strict";(self.webpackChunkowlprotocol_contracts_docs=self.webpackChunkowlprotocol_contracts_docs||[]).push([[7554],{7522:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var r=a(9901);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),i=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=i(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),y=i(a),d=n,m=y["".concat(s,".").concat(d)]||y[d]||u[d]||l;return a?r.createElement(m,o(o({ref:t},p),{},{components:a})):r.createElement(m,o({ref:t},p))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,o=new Array(l);o[0]=y;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:n,o[1]=c;for(var i=2;i<l;i++)o[i]=a[i];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}y.displayName="MDXCreateElement"},7006:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var r=a(2875),n=a(358),l=(a(9901),a(7522)),o=["components"],c={},s=void 0,i={unversionedId:"contract-docs/AcceptEverythingPaymaster",id:"contract-docs/AcceptEverythingPaymaster",title:"AcceptEverythingPaymaster",description:"AcceptEverythingPaymaster",source:"@site/docs/contract-docs/AcceptEverythingPaymaster.md",sourceDirName:"contract-docs",slug:"/contract-docs/AcceptEverythingPaymaster",permalink:"/contracts/docs/contract-docs/AcceptEverythingPaymaster",draft:!1,editUrl:"https://github.com/owlprotocol/contracts/docs/contract-docs/AcceptEverythingPaymaster.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Solidity Reference",permalink:"/contracts/docs/contract-docs/"},next:{title:"AuctionLib",permalink:"/contracts/docs/contract-docs/AuctionLib"}},p={},u=[{value:"AcceptEverythingPaymaster",id:"accepteverythingpaymaster",level:2},{value:"versionPaymaster",id:"versionpaymaster",level:3},{value:"preRelayedCall",id:"prerelayedcall",level:3},{value:"postRelayedCall",id:"postrelayedcall",level:3}],y={toc:u};function d(e){var t=e.components,a=(0,n.Z)(e,o);return(0,l.kt)("wrapper",(0,r.Z)({},y,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"accepteverythingpaymaster"},"AcceptEverythingPaymaster"),(0,l.kt)("h3",{id:"versionpaymaster"},"versionPaymaster"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function versionPaymaster() external view virtual returns (string)\n")),(0,l.kt)("h3",{id:"prerelayedcall"},"preRelayedCall"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function preRelayedCall(struct GsnTypes.RelayRequest relayRequest, bytes signature, bytes approvalData, uint256 maxPossibleGas) external virtual returns (bytes context, bool revertOnRecipientRevert)\n")),(0,l.kt)("p",null,"Called by Relay (and RelayHub), to validate if the paymaster agrees to pay for this call."),(0,l.kt)("p",null,"MUST be protected with relayHubOnly() in case it modifies state."),(0,l.kt)("p",null,'The Paymaster rejects by the following "revert" operations'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"preRelayedCall() method reverts"),(0,l.kt)("li",{parentName:"ul"},"the forwarder reverts because of nonce or signature error"),(0,l.kt)("li",{parentName:"ul"},'the paymaster returned "rejectOnRecipientRevert", and the recipient contract reverted.\nIn any of the above cases, all paymaster calls (and recipient call) are reverted.\nIn any other case, the paymaster agrees to pay for the gas cost of the transaction (note\nthat this includes also postRelayedCall revert)')),(0,l.kt)("p",null,'The rejectOnRecipientRevert flag means the Paymaster "delegate" the rejection to the recipient\ncode.  It also means the Paymaster trust the recipient to reject fast: both preRelayedCall,\nforwarder check and receipient checks must fit into the GasLimits.acceptanceBudget,\notherwise the TX is paid by the Paymaster.'),(0,l.kt)("p",null," @param relayRequest - the full relay request structure\n@param signature - user's EIP712-compatible signature of the {@link relayRequest}.\nNote that in most cases the paymaster shouldn't try use it at all. It is always checked\nby the forwarder immediately after preRelayedCall returns.\n@param approvalData - extra dapp-specific data (e.g. signature from trusted party)\n@param maxPossibleGas - based on values returned from {@link getGasAndDataLimits},\nthe RelayHub will calculate the maximum possible amount of gas the user may be charged for.\nIn order to convert this value to wei, the Paymaster has to call \"relayHub.calculateCharge()\"\nreturn:\na context to be passed to postRelayedCall\nrejectOnRecipientRevert - TRUE if paymaster want to reject the TX if the recipient reverts.\nFALSE means that rejects by the recipient will be completed on chain, and paid by the paymaster.\n(note that in the latter case, the preRelayedCall and postRelayedCall are not reverted)."),(0,l.kt)("h3",{id:"postrelayedcall"},"postRelayedCall"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function postRelayedCall(bytes context, bool success, uint256 gasUseWithoutPost, struct GsnTypes.RelayData relayData) external virtual\n")),(0,l.kt)("p",null,"This method is called after the actual relayed function call.\nIt may be used to record the transaction (e.g. charge the caller by some contract logic) for this call."),(0,l.kt)("p",null,"MUST be protected with relayHubOnly() in case it modifies state."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"context"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes"),(0,l.kt)("td",{parentName:"tr",align:null},"- the call context, as returned by the preRelayedCall")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"success"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"- true if the relayed call succeeded, false if it reverted")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gasUseWithoutPost"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"- the actual amount of gas used by the entire transaction, EXCEPT        the gas used by the postRelayedCall itself.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relayData"),(0,l.kt)("td",{parentName:"tr",align:null},"struct GsnTypes.RelayData"),(0,l.kt)("td",{parentName:"tr",align:null},"- the relay params of the request. can be used by relayHub.calculateCharge() Revert in this functions causes a revert of the client's relayed call (and preRelayedCall(), but the Paymaster is still committed to pay the relay for the entire transaction.")))))}d.isMDXComponent=!0}}]);