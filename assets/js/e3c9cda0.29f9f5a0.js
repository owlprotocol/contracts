"use strict";(self.webpackChunkowlprotocol_contracts_docs=self.webpackChunkowlprotocol_contracts_docs||[]).push([[6766],{7522:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>m});var n=a(9901);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function d(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var o=n.createContext({}),s=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=s(t.components);return n.createElement(o.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,o=t.parentName,p=d(t,["components","mdxType","originalType","parentName"]),c=s(a),m=r,k=c["".concat(o,".").concat(m)]||c[m]||u[m]||l;return a?n.createElement(k,i(i({ref:e},p),{},{components:a})):n.createElement(k,i({ref:e},p))}));function m(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=c;var d={};for(var o in e)hasOwnProperty.call(e,o)&&(d[o]=e[o]);d.originalType=t,d.mdxType="string"==typeof t?t:r,i[1]=d;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},3572:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>d,metadata:()=>s,toc:()=>u});var n=a(2875),r=a(358),l=(a(9901),a(7522)),i=["components"],d={},o=void 0,s={unversionedId:"contract-docs/Rent",id:"contract-docs/Rent",title:"Rent",description:"Rent",source:"@site/docs/contract-docs/Rent.md",sourceDirName:"contract-docs",slug:"/contract-docs/Rent",permalink:"/contracts/docs/contract-docs/Rent",draft:!1,editUrl:"https://github.com/owlprotocol/contracts/docs/contract-docs/Rent.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"RandomBeacon",permalink:"/contracts/docs/contract-docs/RandomBeacon"},next:{title:"RosalindDNA",permalink:"/contracts/docs/contract-docs/RosalindDNA"}},p={},u=[{value:"Rent",id:"rent",level:2},{value:"version",id:"version",level:3},{value:"ERC165TAG",id:"erc165tag",level:3},{value:"Create",id:"create",level:3},{value:"Pay",id:"pay",level:3},{value:"End",id:"end",level:3},{value:"Claim",id:"claim",level:3},{value:"RentalTerms",id:"rentalterms",level:3},{value:"acceptableToken",id:"acceptabletoken",level:3},{value:"shadowAddr",id:"shadowaddr",level:3},{value:"contractAddr",id:"contractaddr",level:3},{value:"numRentals",id:"numrentals",level:3},{value:"rentTermsId",id:"renttermsid",level:3},{value:"timePeriodsPaid",id:"timeperiodspaid",level:3},{value:"balances",id:"balances",level:3},{value:"constructor",id:"constructor",level:3},{value:"initialize",id:"initialize",level:3},{value:"proxyInitialize",id:"proxyinitialize",level:3},{value:"__Rent_init",id:"__rent_init",level:3},{value:"__Rent_init_unchained",id:"__rent_init_unchained",level:3},{value:"createRental",id:"createrental",level:3},{value:"startRent",id:"startrent",level:3},{value:"payRent",id:"payrent",level:3},{value:"endRental",id:"endrental",level:3},{value:"ownerClaim",id:"ownerclaim",level:3},{value:"getRental",id:"getrental",level:3},{value:"getNumRentals",id:"getnumrentals",level:3},{value:"getTimePeriodsPaid",id:"gettimeperiodspaid",level:3},{value:"getTimePeriodsLeftToPay",id:"gettimeperiodslefttopay",level:3},{value:"getBalance",id:"getbalance",level:3},{value:"supportsInterface",id:"supportsinterface",level:3}],c={toc:u};function m(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"rent"},"Rent"),(0,l.kt)("p",null,'This Rent contract serves as a middleman and allows owners of NFTs to lock their assets in this\nsmart contract for a fixed epoch period. The contract then mints a new identical "shadow" NFT on a separate\nsmart contract. This "shadow" NFT can be sold and transferred like any other NFT when being rented. However,\nafter the epoch is finished, the "shadow" NFT is destroyed and the original NFT is returned to its original owner.\nThis contract can handle multiple rentals at a time and keeps track of rental instances using a rentId. This contract\nis great for allowing owners of NFTs to earn income by renting out their assets and incentivizes renters to get a\nchance to temporarily own a cool NFT.'),(0,l.kt)("h3",{id:"version"},"version"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"string version\n")),(0,l.kt)("h3",{id:"erc165tag"},"ERC165TAG"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"bytes4 ERC165TAG\n")),(0,l.kt)("h3",{id:"create"},"Create"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Create(uint256 rentId, address owner, address renter, uint256 nftId, uint256 timePeriods, uint256 pricePerPeriod, uint256 expireTimePerPeriod)\n")),(0,l.kt)("h3",{id:"pay"},"Pay"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Pay(uint256 rentId, uint256 amountPaid)\n")),(0,l.kt)("h3",{id:"end"},"End"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event End(uint256 rentId, uint256 amountPaid)\n")),(0,l.kt)("h3",{id:"claim"},"Claim"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Claim(address owner, uint256 amountClaimed)\n")),(0,l.kt)("h3",{id:"rentalterms"},"RentalTerms"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct RentalTerms {\n  uint256 nftId;\n  address owner;\n  address renter;\n  bool ended;\n  uint256 timePeriods;\n  uint256 pricePerPeriod;\n  uint256 expireTimePerPeriod;\n}\n")),(0,l.kt)("h3",{id:"acceptabletoken"},"acceptableToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"address acceptableToken\n")),(0,l.kt)("h3",{id:"shadowaddr"},"shadowAddr"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"address shadowAddr\n")),(0,l.kt)("h3",{id:"contractaddr"},"contractAddr"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"address contractAddr\n")),(0,l.kt)("h3",{id:"numrentals"},"numRentals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 numRentals\n")),(0,l.kt)("h3",{id:"renttermsid"},"rentTermsId"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(uint256 => struct Rent.RentalTerms) rentTermsId\n")),(0,l.kt)("h3",{id:"timeperiodspaid"},"timePeriodsPaid"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(uint256 => uint256) timePeriodsPaid\n")),(0,l.kt)("h3",{id:"balances"},"balances"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => uint256) balances\n")),(0,l.kt)("h3",{id:"constructor"},"constructor"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"constructor() public\n")),(0,l.kt)("h3",{id:"initialize"},"initialize"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function initialize(address _admin, address _acceptableToken, address _contractAddr, address _shadowAddr, address _forwarder) external\n")),(0,l.kt)("p",null,"Initializing the Rent contract"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_admin"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"address of the launcher, which is this contract")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_acceptableToken"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"accepted ERC20 token for payment")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_contractAddr"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"contract address for original NFT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_shadowAddr"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},'address where "shadow" NFT is minted')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_forwarder"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"address for trusted forwarder for openGSN")))),(0,l.kt)("h3",{id:"proxyinitialize"},"proxyInitialize"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function proxyInitialize(address _admin, address _acceptableToken, address _contractAddr, address _shadowAddr, address _forwarder) external\n")),(0,l.kt)("h3",{id:"__rent_init"},"__Rent_init"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function __Rent_init(address _admin, address _acceptableToken, address _contractAddr, address _shadowAddr, address _forwarder) internal\n")),(0,l.kt)("h3",{id:"__rent_init_unchained"},"__Rent_init_unchained"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function __Rent_init_unchained(address _admin, address _acceptableToken, address _contractAddr, address _shadowAddr) internal\n")),(0,l.kt)("h3",{id:"createrental"},"createRental"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function createRental(struct Rent.RentalTerms rentalTerm) external\n")),(0,l.kt)("p",null,"Creates a single Rental based on the inputted Rental Term Struct that outlines all of the terms\nfor that specific rental instance.\nUpdates the various mappings and gives the Rental an ID.\nIncrements the number of Rentals handled by this contract"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentalTerm"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Rent.RentalTerms"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted rental term struct")))),(0,l.kt)("h3",{id:"startrent"},"startRent"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function startRent(uint256 rentId) external payable\n")),(0,l.kt)("p",null,"this function can only be called at the very start of a Rental process. It must be called\nto mint the shadow NFT"),(0,l.kt)("p",null,"Starts the payment process for the Rental with rentId with it's first payment"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted Rental ID that is used in the mapping to get the corresponding rental term struct")))),(0,l.kt)("h3",{id:"payrent"},"payRent"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function payRent(uint256 rentId, uint256 timePeriodsToPay) public payable\n")),(0,l.kt)("p",null,"function that allows a renter to pay rent for any number of time periods"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted Rental ID that is used in the mapping to get the corresponding rental term struct")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"timePeriodsToPay"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"allows the renter to decide how many time periods they want to pay for at once")))),(0,l.kt)("h3",{id:"endrental"},"endRental"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function endRental(uint256 rentalId) external payable\n")),(0,l.kt)("p",null,"this function only updates the boolean for the rent status (ended vs not) and\ntransfers the ownership of the NFT back to its owner. It does not give funds to the owner in ERC20 tokens"),(0,l.kt)("p",null,"this function allows the owner to end the rental at any point in time"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentalId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted Rental ID that is used in the mapping to get the corresponding rental term struct")))),(0,l.kt)("h3",{id:"ownerclaim"},"ownerClaim"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function ownerClaim() external payable\n")),(0,l.kt)("p",null,"this function enables the owner to claim the balances paid by the renter"),(0,l.kt)("h3",{id:"getrental"},"getRental"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getRental(uint256 rentId) external view returns (struct Rent.RentalTerms)\n")),(0,l.kt)("p",null,"gets a rental instance based on the inputted rentId"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted rental term struct id")))),(0,l.kt)("h3",{id:"getnumrentals"},"getNumRentals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNumRentals() external view returns (uint256)\n")),(0,l.kt)("p",null,"gets the number of rentals created on this contract"),(0,l.kt)("h3",{id:"gettimeperiodspaid"},"getTimePeriodsPaid"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getTimePeriodsPaid(uint256 rentalId) external view returns (uint256)\n")),(0,l.kt)("p",null,"gets the number of time periods paid by a renter for a specific Rental based on the inputted rentId"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentalId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted rental term struct id")))),(0,l.kt)("h3",{id:"gettimeperiodslefttopay"},"getTimePeriodsLeftToPay"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getTimePeriodsLeftToPay(uint256 rentalId) external view returns (uint256)\n")),(0,l.kt)("p",null,"gets how many time periods are left to pay for a specific Rental"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rentalId"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"inputted rental term struct id")))),(0,l.kt)("h3",{id:"getbalance"},"getBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getBalance(address owner) external view returns (uint256)\n")),(0,l.kt)("p",null,"gets the total balance that is claimable by an owner"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"owner"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"owner of a Rental that can call this function to see how much they can claim")))),(0,l.kt)("h3",{id:"supportsinterface"},"supportsInterface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n")),(0,l.kt)("p",null,"ERC165 Support"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"interfaceId"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes4"),(0,l.kt)("td",{parentName:"tr",align:null},"hash of the interface testing for")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool whether interface is supported")))))}m.isMDXComponent=!0}}]);